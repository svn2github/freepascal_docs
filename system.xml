<?xml version="1.0" encoding="ISO8859-1"?>
<fpdoc-descriptions>
<!--  

   $Id: system.xml,v 1.6 2005/05/07 09:41:09 michael Exp $ 
   This file is part of the FPC documentation. 
   Copyright (C) 1997, by Michael Van Canneyt 
 
   The FPC documentation is free text; you can redistribute it and/or 
   modify it under the terms of the GNU Library General Public License as 
   published by the Free Software Foundation; either version 2 of the 
   License, or (at your option) any later version. 
 
   The FPC Documentation is distributed in the hope that it will be useful, 
   but WITHOUT ANY WARRANTY; without even the implied warranty of 
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
   Library General Public License for more details. 
 
   You should have received a copy of the GNU Library General Public 
   License along with the FPC documentation; see the file COPYING.LIB.  If not, 
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
   Boston, MA 02111-1307, USA. 
 -->
<package name="rtl">
<module name="system">
<short>The system unit</short>
<!-- \FPCexampledir{refex} -->
<descr>
<p>
The system unit contains the standard supported functions of Free Pascal. It is the
same for all platforms. Basically it is the same as the system unit provided
with Borland or Turbo Pascal.
</p>
<p>
Functions are listed in alphabetical order. Arguments of functions or
procedures that are optional are put between square brackets.
</p>
<p>
The pre-defined constants and variables are listed in the first section.
The second section contains an overview of all functions, grouped by
functionality, and the last section contains the supported functions
and procedures.
</p>
</descr>

<topic name="FileFunctions">
<short>File handling functions</short>
<descr>
<p>
Functions concerning input and output from and to file.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Append"/></td><td>Open a file in append mode</td></tr>
<tr><td><link id="Assign"/></td><td>Assign a name to a file</td></tr>
<tr><td><link id="Blockread"/></td><td>Read data from a file into memory</td></tr>
<tr><td><link id="Blockwrite"/></td><td>Write data from memory to a file</td></tr>
<tr><td><link id="Close"/></td><td>Close a file</td></tr>
<tr><td><link id="Eof"/></td><td>Check for end of file</td></tr>
<tr><td><link id="Eoln"/></td><td>Check for end of line</td></tr>
<tr><td><link id="Erase"/></td><td>Delete  file from disk</td></tr>
<tr><td><link id="Filepos"/></td><td>Position in file</td></tr>
<tr><td><link id="Filesize"/></td><td>Size of file</td></tr>
<tr><td><link id="Flush"/></td><td>Write file buffers to disk</td></tr>
<tr><td><link id="IOresult"/></td><td>Return result of last file IO operation</td></tr>
<tr><td><link id="Read"/></td><td>Read from file into variable</td></tr>
<tr><td><link id="Readln"/></td><td>Read from file into variable and goto next line</td></tr>
<tr><td><link id="Rename"/></td><td>Rename file on disk</td></tr>
<tr><td><link id="Reset"/></td><td>Open file for reading</td></tr>
<tr><td><link id="Rewrite"/></td><td>Open file for writing</td></tr>
<tr><td><link id="Seek"/></td><td>Set file position</td></tr>
<tr><td><link id="SeekEof"/></td><td>Set file position to end of file</td></tr>
<tr><td><link id="SeekEoln"/></td><td>Set file position to end of line</td></tr>
<tr><td><link id="SetTextBuf"/></td><td>Set size of file buffer</td></tr>
<tr><td><link id="Truncate"/></td><td>Truncate the file at position</td></tr>
<tr><td><link id="Write"/></td><td>Write variable to file</td></tr>
<tr><td><link id="WriteLn"/></td><td>Write variable to file and append newline</td></tr>
</table>
</descr>
</topic>

<topic name="MemoryFunctions">
<short>Memory management functions</short>
<descr>
<p>
Functions concerning memory issues.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Addr"/></td><td>Return address of variable</td></tr>
<tr><td><link id="Assigned"/></td><td>Check if a pointer is valid</td></tr>
<tr><td><link id="CompareByte"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CompareChar"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CompareDWord"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CompareWord"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CSeg"/></td><td>Return code segment</td></tr>
<tr><td><link id="Dispose"/></td><td>Free dynamically allocated memory</td></tr>
<tr><td><link id="DSeg"/></td><td>Return data segment</td></tr>
<tr><td><link id="FillByte"/></td><td>Fill memory region with 8-bit pattern</td></tr>
<tr><td><link id="Fillchar"/></td><td>Fill memory region with certain character</td></tr>
<tr><td><link id="FillDWord"/></td><td>Fill memory region with 32-bit pattern</td></tr>
<tr><td><link id="Fillword"/></td><td>Fill memory region with 16-bit pattern</td></tr>
<tr><td><link id="Freemem"/></td><td>Release allocated memory</td></tr>
<tr><td><link id="Getmem"/></td><td>Allocate new memory</td></tr>
<tr><td><link id="GetMemoryManager"/></td><td>Return current memory manager</td></tr>
<tr><td><link id="High"/></td><td>Return highest index of open array or enumerated</td></tr>
<tr><td><link id="IsMemoryManagerSet"/></td><td>Is the memory manager set</td></tr>
<tr><td><link id="Low"/></td><td>Return lowest index of open array or enumerated</td></tr>
<tr><td><link id="Move"/></td><td>Move data from one location in memory to another</td></tr>
<tr><td><link id="MoveChar0">MoveChar0</link></td><td>Move data till first zero character</td></tr>
<tr><td><link id="New"/></td><td>Dynamically allocate memory for variable</td></tr>
<tr><td><link id="Ofs"/></td><td>Return offset of variable</td></tr>
<tr><td><link id="Ptr"/></td><td>Combine segment and offset to pointer</td></tr>
<tr><td><link id="ReAllocMem"/></td><td>Resize a memory block on the heap</td></tr>
<tr><td><link id="Seg"/></td><td>Return segment</td></tr>
<tr><td><link id="SetMemoryManager"/></td><td>Set a memory manager</td></tr>
<tr><td><link id="Sptr"/></td><td>Return current stack pointer</td></tr>
<tr><td><link id="SSeg"/></td><td>Return stack segment register value</td></tr>
</table>
</descr>
</topic>

<topic name="MathematicalFunctions">
<short>Mathematical routines</short>
<descr>
<p>
Functions connected to calculating and coverting numbers.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Abs"/></td><td>Calculate absolute value</td></tr>
<tr><td><link id="Arctan"/></td><td>Calculate inverse tangent</td></tr>
<tr><td><link id="Cos"/></td><td>Calculate cosine of angle</td></tr>
<tr><td><link id="Dec"/></td><td>Decrease value of variable</td></tr>
<tr><td><link id="Exp"/></td><td>Exponentiate</td></tr>
<tr><td><link id="Frac"/></td><td>Return fractional part of floating point value</td></tr>
<tr><td><link id="Hi"/></td><td>Return high byte/word of value</td></tr>
<tr><td><link id="Inc"/></td><td>Increase value of variable</td></tr>
<tr><td><link id="Int"/></td><td>Calculate integer part of floating point value</td></tr>
<tr><td><link id="Ln"/></td><td>Calculate logarithm</td></tr>
<tr><td><link id="Lo"/></td><td>Return low byte/word of value</td></tr>
<tr><td><link id="Odd"/></td><td>Is a value odd or even ? </td></tr>
<tr><td><link id="Pi"/></td><td>Return the value of pi</td></tr>
<tr><td><link id="Power"/></td><td>Raise float to integer power</td></tr>
<tr><td><link id="Random"/></td><td>Generate random number</td></tr>
<tr><td><link id="Randomize"/></td><td>Initialize random number generator</td></tr>
<tr><td><link id="Round"/></td><td>Round floating point value to nearest integer number</td></tr>
<tr><td><link id="Sin"/></td><td>Calculate sine of angle</td></tr>
<tr><td><link id="Sqr"/></td><td>Calculate the square of a value</td></tr>
<tr><td><link id="Sqrt"/></td><td>Calculate the square root of a value</td></tr>
<tr><td><link id="Swap"/></td><td>Swap high and low bytes/words of a variable</td></tr>
<tr><td><link id="Trunc"/></td><td>Truncate a floating point value</td></tr>
</table>
</descr>
</topic>

<topic name="StringFunctions">
<short>String handling</short>
<descr>
<p>
All things connected to string handling.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="BinStr"/></td><td>Construct binary representation of integer</td></tr>
<tr><td><link id="Chr"/></td><td>Convert ASCII code to character</td></tr>
<tr><td><link id="Concat"/></td><td>Concatenate two strings</td></tr>
<tr><td><link id="Copy"/></td><td>Copy part of a string</td></tr>
<tr><td><link id="Delete"/></td><td>Delete part of a string</td></tr>
<tr><td><link id="HexStr"/></td><td>Construct hexadecimal representation of integer</td></tr>
<tr><td><link id="Insert"/></td><td>Insert one string in another</td></tr>
<tr><td><link id="Length"/></td><td>Return length of string</td></tr>
<tr><td><link id="Lowercase"/></td><td>Convert string to all-lowercase</td></tr>
<tr><td><link id="OctStr"/></td><td>Construct octal representation of integer</td></tr>
<tr><td><link id="Pos"/></td><td>Calculate position of one string in another</td></tr>
<tr><td><link id="SetLength"/></td><td>Set length of a string</td></tr>
<tr><td><link id="SetString"/></td><td>Set contents and length of a string</td></tr>
<tr><td><link id="Str"/></td><td>Convert number to string representation</td></tr>
<tr><td><link id="StringOfChar"/></td><td>Create string consisting of a number of characters</td></tr>
<tr><td><link id="Upcase"/></td><td>Convert string to all-uppercase</td></tr>
<tr><td><link id="Val"/></td><td>Convert string to number</td></tr>
</table>
</descr>
</topic>

<topic name="OSfunctions">
<short>Operating System functions</short>
<descr>
<p>
Functions that are connected to the operating system.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Chdir"/></td><td>Change working directory</td></tr>
<tr><td><link id="Getdir"/></td><td>Return current working directory</td></tr>
<tr><td><link id="Halt"/></td><td>Halt program execution</td></tr>
<tr><td><link id="Paramcount"/></td><td>Number of parameters with which program was called</td></tr>
<tr><td><link id="Paramstr"/></td><td>Retrieve parameters with which program was called</td></tr>
<tr><td><link id="Mkdir"/></td><td>Make a directory</td></tr>
<tr><td><link id="Rmdir"/></td><td>Remove a directory</td></tr>
<tr><td><link id="Runerror"/></td><td>Abort program execution with error condition</td></tr>
</table>
</descr>
</topic>

<topic name="MiscellaneousFunctions">
<short>Miscellaneous functions</short>
<descr>
<p>
Functions that do not belong in one of the other categories.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Assert"/></td><td>Conditionally abort program with error</td></tr>
<tr><td><link id="Break"/></td><td>Abort current loop</td></tr>
<tr><td><link id="Continue"/></td><td>Next cycle in current loop</td></tr>
<tr><td><link id="Exclude"/></td><td>Exclude an element from a set</td></tr>
<tr><td><link id="Exit"/></td><td>Exit current function or procedure</td></tr>
<tr><td><link id="Include"/></td><td>Include an element into a set</td></tr>
<tr><td><link id="LongJmp"/></td><td>Jump to execution point</td></tr>
<tr><td><link id="Ord"/></td><td>Return ordinal value of enumerated type</td></tr>
<tr><td><link id="Pred"/></td><td>Return previous value of ordinal type</td></tr>
<tr><td><link id="SetJmp"/></td><td>Mark execution point for jump</td></tr>
<tr><td><link id="SizeOf"/></td><td>Return size of variable or type</td></tr>
<tr><td><link id="Succ"/></td><td>Return next value of ordinal type</td></tr>
</table>
</descr>
</topic>

<element name="Abs">
<short>Calculate absolute value</short>
<descr>
<var>Abs</var> returns the absolute value of a variable. The result of the
function has the same type as its argument, which can be any numerical
type.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Round"/>
</seealso>
<example file="refex/ex1"/>
</element>



<element name="Addr">
<short>Return address of a variable</short>
<descr>
<var>Addr</var> returns a pointer to its argument, which can be any type, or a
function or procedure name. The returned pointer isn't typed.
The same result can be obtained by the <var>@</var> operator, which can return a
typed pointer (\progref).
</descr>
<errors>
None
</errors>
<seealso>
<link id="SizeOf"/>
</seealso>
<example file="refex/ex2"/>
</element>



<element name="Append">
<short>Open a file in append mode</short>
<descr>
<var>Append</var> opens an existing file in append mode. Any data written to
<var>F</var> will be appended to the file. Only text files can be opened in
append mode. After a call to <var>Append</var>, the file <var>F</var> becomes
write-only.

File sharing is not taken into account when calling <var>Append</var>.

</descr>
<errors>
If the file doesn't exist when appending, a run-time error will be generated.
This behaviour has changed on Windows and Linux platforms, where in versions
prior to 1.0.6, the file would be created in append mode.
</errors>
<seealso>
<link id="Rewrite"/>
<link id="Close"/>
<link id="Reset"/>
</seealso>
<example file="refex/ex3"/>
</element>



<element name="Arctan">
<short>Calculate inverse tangent</short>
<descr>
<var>Arctan</var> returns the Arctangent of <var>X</var>, which can be any Real type.
The resulting angle is in radial units.
</descr>
<errors>
None
</errors>
<seealso>
<link id="Sin"/>
<link id="Cos"/>
</seealso>
<example file="refex/ex4"/>
</element>



<element name="Assert">
<short>Check validity of a given condition.</short>
<descr>
With assertions on, <var>Assert</var> tests if <var>expr</var> is 
false, and if so, aborts the application with a Runtime error 
227 and an optional error message in <var>msg</var>.
If <var>expr</var> is true, program execution continues normally. 

If assertions are not enabled at compile time, this routine does 
nothing, and no code is generated for the <var>Assert</var> call. 

Enabling and disabling assertions at compile time is done via
the <var>\$C</var> or <var>\$ASSERTIONS</var> compiler switches. These are
global switches.

The default behavior of the assert call can be changed by 
setting a new handler in the <var>AssertErrorProc</var> variable.
Sysutils overrides the default handler to raise a <var>EAssertionFailed</var> 
exception.


</descr>
<errors>
None.
</errors>
<seealso>
<link id="Halt"/>
<link id="Runerror"/>
</seealso>
</element>


<element name="Assign">
<short>Assign a name to a file</short>
<descr>
<var>Assign</var> assigns a name to <var>F</var>, which can be any file type.
This call doesn't open the file, it just assigns a name to a file variable,
and marks the file as closed.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Reset"/>
<link id="Rewrite"/>
<link id="Append"/>
</seealso>
<example file="refex/ex5"/>
</element>



<element name="Assigned">
<short>Check if a pointer is valid</short>
<descr>
<var>Assigned</var> returns <var>True</var> if <var>P</var> is non-nil
and retuns <var>False</var> of <var>P</var> is nil.
The main use of Assigned is that Procedural variables, method variables and
class-type variables also can be passed to <var>Assigned</var>.
</descr>
<errors>
None
</errors>
<seealso>
<link id="New"/>
</seealso>
<example file="refex/ex96"/>
</element>



<element name="BinStr">
<short>Convert integer to string with binary representation.</short>
<descr>
<var>BinStr</var> returns a string with the binary representation
of <var>Value</var>. The string has at most <var>cnt</var> characters.
(i.e. only the <var>cnt</var> rightmost bits are taken into account)
To have a complete representation of any longint-type value, 32
bits are needed, i.e. <var>cnt=32</var>

</descr>
<errors>
None.
</errors>
<seealso>
<link id="Str"/>
<link id="Val"/>
<link id="HexStr"/>
<link id="OctStr"/>
</seealso>
<example file="refex/ex82"/>
</element>



<element name="Blockread">
<short>Read data from an untyped file into memory</short>
<descr>
<var>Blockread</var> reads <var>count</var> or less records from file <var>F</var>. A
record is a block of bytes with size specified by the <link id="Rewrite"/> or
<link id="Reset"/> statement.

The result is placed in <var>Buffer</var>, which must contain enough room for
<var>Count</var> records. The function cannot read partial records.
If <var>Result</var> is specified, it contains the number of records actually
read. If <var>Result</var> isn't specified, and less than <var>Count</var> records were
read, a run-time error is generated. This behavior can be controlled by the
\var{\{\$i\}} switch.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Blockwrite"/>
<link id="Close"/>
<link id="Reset"/>
<link id="Assign"/>
</seealso>
<example file="refex/ex6"/>
</element>



<element name="Blockwrite">
<short>Write data from memory to an untyped file</short>
<descr>
<var>BlockWrite</var> writes <var>count</var> records from <var>buffer</var> to the file
 <var>F</var>.A record is a block of bytes with size specified by the <link id="Rewrite"/> or
<link id="Reset"/> statement.

If the records couldn't be written to disk, a run-time error is generated.
This behavior can be controlled by the \var{\{\$i\}} switch.

</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Blockread"/>
<link id="Close"/>
<link id="Rewrite"/>
<link id="Assign"/>
</seealso>
</element>

For the example, see <link id="Blockread"/>.

<element name="Break">
<short>Exit current loop construct.</short>
<descr>
<p>
<var>Break</var> jumps to the statement following the end of the current
repetitive statement. The code between the <var>Break</var> call and
the end of the repetitive statement is skipped.
The condition of the repetitive statement is NOT evaluated.
</p>
<p>
This can be used with <var>For</var>, var{repeat} and <var>While</var> statements.
</p>
<p>
Note that while this is a procedure, <var>Break</var> is a reserved word
and hence cannot be redefined.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Continue"/>
<link id="Exit"/>
</seealso>
<example file="refex/ex87"/>
</element>



<element name="Chdir">
<short>Change current working directory.</short>
<descr>
<var>Chdir</var> changes the working directory of the process to <var>S</var>.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Mkdir"/>
<link id="Rmdir"/>
</seealso>
<example file="refex/ex7"/>
</element>



<element name="Chr">
<short>Convert byte value to character value</short>
<descr>
<p>
<var>Chr</var> returns the character which has ASCII value <var>X</var>.
</p>
<p>
Historical note:
</p>
<p>
Originally, Pascal did not have typecasts and chr was a necessary function in
order to do certain operations on ASCII values of characters. With the arrival of
typecasting a generic approach became possible, making chr mostly obselete.
However, chr is not considered deprecated and remains in wide use today.
</p></descr>
<errors>
None.
</errors>
<seealso>
<link id="Ord"/>
<link id="Str"/>
</seealso>
<example file="refex/ex8"/>
</element>



<element name="Close">
<short>Close a file</short>
<descr>
<var>Close</var> flushes the buffer of the file <var>F</var> and closes <var>F</var>.
After a call to <var>Close</var>, data can no longer be read from or written to
<var>F</var>.
To reopen a file closed with <var>Close</var>, it isn't necessary to assign the
file again. A call to <link id="Reset"/> or <link id="Rewrite"/> is sufficient.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
<link id="Flush"/>
</seealso>
<example file="refex/ex9"/>
</element>



<element name="CompareByte">
<short>Compare 2 memory buffers byte per byte</short>
<descr>
<p>
<var>CompareByte</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
byte-per-byte basis for a total of <var>len</var> bytes.
</p>
<p>
The function returns one of the following values:
</p>
<dl>
<dt>less than 0</dt>
<dd> if <var>buf1</var> and <var>buf2</var> contain different bytes
in the first <var>len</var> bytes, and the first such byte is smaller in <var>buf1</var>
than the byte at the same position in <var>buf2</var>.
</dd>
<dt>0</dt>
<dd>  if the first <var>len</var> bytes in <var>buf1</var> and <var>buf2</var> are
equal.
\item [greater than 0] if <var>buf1</var> and <var>buf2</var> contain different bytes
in the first <var>len</var> bytes, and the first such byte is larger in <var>buf1</var>
than the byte at the same position in <var>buf2</var>.
</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareChar"/>
<link id="CompareWord"/>
<link id="CompareDWord"/>
</seealso>
<example file="refex/ex99"/>
</element>



<element name="CompareChar">
<short>ompare 2 memory buffers character per character</short>
<descr>
<p>
<var>CompareChar</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
character-per-character basis for a total of <var>len</var> characters.
</p>
<p>
The <var>CompareChar0</var> variant compares <var>len</var> bytes, or until
a zero character is found.
</p>
<p>
The function returns one of the following values:
</p>
<dl>
<dt>-1</dt>
<dd> if <var>buf1</var> and <var>buf2</var> contain different characters
in the first <var>len</var> positions, and the first such character is smaller in <var>buf1</var>
than the character at the same position in <var>buf2</var>.
</dd>
<dt>0</dt>
<dd>  if the first <var>len</var> characters in <var>buf1</var> and <var>buf2</var> are
equal.
</dd>
<dt>1</dt>
<dd>if <var>buf1</var> and <var>buf2</var> contain different characters
in the first <var>len</var> positions, and the first such character is larger in
<var>buf1</var> than the character at the same position in <var>buf2</var>.
</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareByte"/>
<link id="CompareWord"/>
<link id="CompareDWord"/>
</seealso>
<example file="refex/ex100"/>
</element>



<element name="CompareDWord">
<short>Compare 2 memory buffers DWord per DWord</short>
<descr>
<p>
<var>CompareDWord</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
DWord-per-DWord basis for a total of <var>len</var> DWords. (A DWord is 4 bytes).
</p>
<p>
The function returns one of the following values:
</p>
<dl>
<dt>-1</dt>
<dd> if <var>buf1</var> and <var>buf2</var> contain different DWords
in the first <var>len</var> DWords, and the first such DWord is smaller in <var>buf1</var>
than the DWord at the same position in <var>buf2</var>.
</dd>
<dt>0</dt>
<dd>  if the first <var>len</var> DWords in <var>buf1</var> and <var>buf2</var> are
equal.
</dd>
<dt>1</dt>
<dd>if <var>buf1</var> and <var>buf2</var> contain different DWords
in the first <var>len</var> DWords, and the first such DWord is larger in <var>buf1</var>
than the DWord at the same position in <var>buf2</var>.
</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareChar"/>
<link id="CompareByte"/>
<link id="CompareWord"/>,
</seealso>
<example file="refex/ex101"/>
</element>



<element name="CompareWord">
<short>Compare 2 memory buffers word per word</short>
<descr>
<p>
<var>CompareWord</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
Word-per-Word basis for a total of <var>len</var> Words. (A Word is 2 bytes).
</p>
<p>
The function returns one of the following values:
</p>
<dl>
<dt>-1</dt>
<dd> if <var>buf1</var> and <var>buf2</var> contain different Words
in the first <var>len</var> Words, and the first such Word is smaller in <var>buf1</var>
than the Word at the same position in <var>buf2</var>.
</dd>
<dt>0</dt>
<dd>  if the first <var>len</var> Words in <var>buf1</var> and <var>buf2</var> are
equal.
</dd>
<dt>1</dt>
<dd>
if <var>buf1</var> and <var>buf2</var> contain different Words
in the first <var>len</var> Words, and the first such Word is larger in <var>buf1</var>
than the Word at the same position in <var>buf2</var>.
</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareChar"/>
<link id="CompareByte"/>
<link id="CompareDWord"/>,
</seealso>
<example file="refex/ex102"/>
</element>



<element name="Concat">
<short>Append one string to another.</short>
<descr>
<var>Concat</var> concatenates the strings <var>S1</var>,<var>S2</var> etc. to one long
string. The resulting string is truncated at a length of 255 bytes.
The same operation can be performed with the <var>+</var> operation.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Copy"/>
<link id="Delete"/>
<link id="Insert"/>
<link id="Pos"/>
<link id="Length"/>
</seealso>
<example file="refex/ex10"/>
</element>



<element name="Continue">
<short>Continue with next loop cycle.</short>
<descr>
<p>
<var>Continue</var> jumps to the end of the current repetitive statement.
The code between the <var>Continue</var> call and the end of the repetitive
statement is skipped. The condition of the repetitive statement is then
checked again.
</p>
<p>
This can be used with <var>For</var>, var{repeat} and <var>While</var> statements.
</p>
<p>
Note that while this is a procedure, <var>Continue</var> is a reserved word
and hence cannot be redefined.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Break"/>
<link id="Exit"/>
</seealso>
<example file="refex/ex86"/>
</element>




<element name="Copy">
<short>Copy part of a string.</short>
<descr>
<var>Copy</var> returns a string which is a copy if the <var>Count</var> characters
in <var>S</var>, starting at position <var>Index</var>. If <var>Count</var> is larger than
the length of the string <var>S</var>, the result is truncated.
If <var>Index</var> is larger than the length of the string <var>S</var>, then an
empty string is returned.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Delete"/>
<link id="Insert"/>
<link id="Pos"/>
</seealso>
<example file="refex/ex11"/>
</element>



<element name="Cos">
<short>Calculate cosine of angle</short>
<descr>
<var>Cos</var> returns the cosine of <var>X</var>, where X is an angle, in radians.

If the absolute value of the argument is larger than 2^63, then the
result is undefined.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Arctan"/>
<link id="Sin"/>
</seealso>
<example file="refex/ex12"/>
</element>



<element name="CSeg">
<short>Return code segment</short>
<descr>
<var>CSeg</var> returns the Code segment register. In Free Pascal, it returns always a
zero, since Free Pascal is a 32 bit compiler.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="DSeg"/>
<link id="Seg"/>
<link id="Ofs"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex13"/>
</element>



<element name="Dec">
<short>Decrease value of variable</short>
<descr>
<var>Dec</var> decreases the value of <var>X</var> with <var>Decrement</var>.
If <var>Decrement</var> isn't specified, then 1 is taken as a default.
</descr>
<errors>
A range check can occur, or an underflow error, if an attempt it made
to decrease <var>X</var> below its minimum value.
</errors>
<seealso>
<link id="Inc"/>
</seealso>
<example file="refex/ex14"/>
</element>



<element name="Delete">
<short>Delete part of a string.</short>
<descr>
<var>Delete</var> removes <var>Count</var> characters from string <var>S</var>, starting
at position <var>Index</var>. All characters after the delected characters are
shifted <var>Count</var> positions to the left, and the length of the string is adjusted.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Copy"/>
<link id="Pos"/>
<link id="Insert"/>
</seealso>
<example file="refex/ex15"/>
</element>



<element name="Dispose">
<short>Free dynamically allocated memory</short>
<descr>
<p>
The first form <var>Dispose</var> releases the memory allocated with a call to
<link id="New"/>. The pointer <var>P</var> must be typed. The released memory is
returned to the heap.
</p>
<p>
The second form of <var>Dispose</var> accepts as a first parameter a pointer
to an object type, and as a second parameter the name of a destructor
of this object. The destructor will be called, and the memory allocated
for the object will be freed.
</p>
</descr>
<errors>
An runtime error will occur if the pointer doesn't point to a location in the
heap.
</errors>
<seealso>
<link id="New"/>
<link id="Getmem"/>
<link id="Freemem"/>
</seealso>
<example file="refex/ex16"/>
</element>



<element name="DSeg">
<short>Return data segment</short>
<descr>
<var>DSeg</var> returns the data segment register. In Free Pascal, it returns always a
zero, since Free Pascal is a 32 bit compiler.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CSeg"/>
<link id="Seg"/>
<link id="Ofs"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex17"/>
</element>



<element name="Eof">
<short>Check for end of file</short>
<descr>
<p>
<var>Eof</var> returns <var>True</var> if the file-pointer has reached the end of the
file, or if the file is empty. In all other cases <var>Eof</var> returns
<var>False</var>.
If no file <var>F</var> is specified, standard input is assumed.
</p>
<p>
Note that calling this function may cause your program to wait: to determine
whether you are at EOF, it is necessary to read data. If the file descriptor
is not a real file (for instance for standard input or sockets) , then this 
call may seem to hang the program while it is waiting for data to appear or
for the file descriptor to be closed.
</p>
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Eoln"/>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
</seealso>
<example file="refex/ex18"/>
</element>



<element name="Eoln">
<short>Check for end of line</short>
<descr>
<var>Eof</var> returns <var>True</var> if the file pointer has reached the end of a
line, which is demarcated by a line-feed character (ASCII value 10), or if
the end of the file is reached.
In all other cases <var>Eof</var> returns <var>False</var>.
If no file <var>F</var> is specified, standard input is assumed.
It can only be used on files of type <var>Text</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Eof"/>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
</seealso>
<example file="refex/ex19"/>
</element>



<element name="Erase">
<short>Delete a file from disk</short>
<descr>
<var>Erase</var> removes an unopened file from disk. The file should be
assigned with <var>Assign</var>, but not opened with <var>Reset</var> or <var>Rewrite</var>
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Assign"/>
</seealso>
<example file="refex/ex20"/>
</element>



<element name="Exclude">
<short>Exlude element from a set if it is present.</short>
<descr>
<p>
<var>Exclude</var> removes <var>E</var> from the set <var>S</var> if it is
included inthe set. E should be of the same type as the base type
of the set <var>S</var>.
</p>
<p>
Thus, the two following statements do the same thing:
</p>
<code>
S:=S-[E];
Exclude(S,E);
</code>
</descr>
<errors>
If the type of the element <var>E</var> is not equal to the base type of the
set <var>S</var>, the compiler will generate an error.
</errors>
<seealso>
<link id="Include"/>
</seealso>
<example file="refex/ex111"/>
</element>



<element name="Exit">
<short>Exit current subroutine.</short>
<descr>
<var>Exit</var> exits the current subroutine, and returns control to the calling
routine. If invoked in the main program routine, exit stops the program.
The optional argument <var>X</var> allows to specify a return value, in the case
<var>Exit</var> is invoked in a function. The function result will then be
equal to <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Halt"/>
</seealso>
<example file="refex/ex21"/>
</element>



<element name="Exp">
<short>Exponentiate</short>
<descr>
<var>Exp</var> returns the exponent of <var>X</var>, i.e. the number <var>e</var> to the
power <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Ln"/>
<link id="Power"/>
</seealso>
<example file="refex/ex22"/>
</element>



<element name="Filepos">
<short>Get position in file</short>
<descr>
<var>Filepos</var> returns the current record position of the file-pointer in file
<var>F</var>. It cannot be invoked with a file of type <var>Text</var>. A compiler error
will be generated if this is attempted.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Filesize"/>
</seealso>
<example file="refex/ex23"/>
</element>



<element name="Filesize">
<short>Size of file</short>
<descr>
<var>Filesize</var> returns the total number of records in file <var>F</var>.
It cannot be invoked with a file of type <var>Text</var>. (under linux and unix, this
also means that it cannot be invoked on pipes).
If <var>F</var> is empty, 0 is returned.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Filepos"/>
</seealso>
<example file="refex/ex24"/>
</element>



<element name="FillByte">
<short>Fill memory region with 8-bit pattern</short>
<descr>
<var>FillByte</var> fills the memory starting at <var>X</var> with <var>Count</var> bytes
with value equal to <var>Value</var>.

This is useful for quickly zeroing out a memory location. When the size of
the memory location to be filled out is a multiple of 2 bytes, it is better
 to use <link id="Fillword"/>, and if it is a multiple of 4 bytes it is better
to use <link id="FillDWord"/>, these routines are optimized for their respective sizes.

</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="Fillchar"/>
<link id="FillDWord"/>
<link id="Fillword"/>
<link id="Move"/>
</seealso>
<example file="refex/ex102"/>
</element>



<element name="Fillchar">
<short>Fill memory region with certain character</short>
<descr>
<var>Fillchar</var> fills the memory starting at <var>X</var> with <var>Count</var> bytes
or characters with value equal to <var>Value</var>.

</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="Fillword"/>
<link id="Move"/>
<link id="FillByte"/>
<link id="FillDWord"/>
</seealso>
<example file="refex/ex25"/>
</element>



<element name="FillDWord">
<short>Fill memory region with 32-bit pattern</short>
<descr>
<var>Fillword</var> fills the memory starting at <var>X</var> with <var>Count</var> DWords
with value equal to <var>Value</var>. A DWord is 4 bytes in size.

</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="FillByte"/>
<link id="Fillchar"/>
<link id="Fillword"/>
<link id="Move"/>
</seealso>
<example file="refex/ex103"/>
</element>



<element name="Fillword">
<short>Fill memory region with 16-bit pattern</short>
<descr>
<var>Fillword</var> fills the memory starting at <var>X</var> with <var>Count</var> words
with value equal to <var>Value</var>. A word is 2 bytes in size.
</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="Fillchar"/>
<link id="Move"/>
</seealso>
<example file="refex/ex76"/>
</element>



<element name="Flush">
<short>Write file buffers to disk</short>
<descr>
<var>Flush</var> empties the internal buffer of an opened file <var>F</var> and writes the
contents to disk. The file is \textit{not} closed as a result of this call.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Close"/>
</seealso>
<example file="refex/ex26"/>
</element>



<element name="Frac">
<short>Return fractional part of floating point value.</short>
<descr>
<var>Frac</var> returns the non-integer part of <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Round"/>
<link id="Int"/>
</seealso>
<example file="refex/ex27"/>
</element>



<element name="Freemem">
<short>Release allocated memory</short>
<descr>
<var>Freemem</var> releases the memory occupied by the pointer <var>P</var>, of size
<var>Count</var> (in bytes), and returns it to the heap. <var>P</var> should point to the memory
allocated to a dynamic variable.
</descr>
<errors>
An error will occur when <var>P</var> doesn't point to the heap.
</errors>
<seealso>
<link id="Getmem"/>
<link id="New"/>
<link id="Dispose"/>
</seealso>
<example file="refex/ex28"/>
</element>


<element name="Getdir">
<short>Return the current directory</short>
<descr>
<var>Getdir</var> returns in <var>dir</var> the current directory on the drive
<var>drivenr</var>, where {drivenr} is 1 for the first floppy drive, 3 for the
first hard disk etc. A value of 0 returns the directory on the current disk.
On linux and unix systems, <var>drivenr</var> is ignored, as there is only one
directory tree.
</descr>
<errors>
An error is returned under dos, if the drive requested isn't ready.
</errors>
<seealso>
<link id="Chdir"/>
</seealso>
<example file="refex/ex29"/>
</element>



<element name="Getmem">
<short>Allocate new memory on the heap</short>
<descr>
<p>
<var>Getmem</var> reserves <var>Size</var> bytes memory on the heap, and returns a
pointer to this memory in <var>p</var>. If no more memory is available, nil is
returned.
</p>
<p>
For an example, see <link id="Freemem"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Freemem"/>
<link id="Dispose"/>
<link id="New"/>
</seealso>
</element>

<element name="GetMemoryManager">
<short>Return current memory manager</short>
<descr>
<p>
<var>GetMemoryManager</var> stores the current Memory Manager record in
<var>MemMgr</var>.
</p>
<p>
For an example, see \progref.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetMemoryManager"/>
<link id="IsMemoryManagerSet"/>.
</seealso>
</element>


<element name="Halt">
<short>Stop program execution.</short>
<descr>
<var>Halt</var> stops program execution and returns control to the calling
program. The optional argument <var>Errnum</var> specifies an exit value. If
omitted, zero is returned.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Exit"/>
</seealso>
<example file="refex/ex30"/>
</element>



<element name="HexStr">
<short>Convert integer value to string with hexadecimal representation.</short>
<descr>
<var>HexStr</var> returns a string with the hexadecimal representation
of <var>Value</var>. The string has exactly <var>cnt</var> charaters.
 (i.e. only the <var>cnt</var> rightmost nibbles are taken into account)
To have a complete representation of a Longint-type value, 8
nibbles are needed, i.e. <var>cnt=8</var>.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="Str"/>
<link id="Val"/>
<link id="BinStr"/>
</seealso>
<example file="refex/ex81"/>
</element>



<element name="Hi">
<short>Return high byte/word of value.</short>
<descr>
<var>Hi</var> returns the high byte or word from <var>X</var>, depending on the size
of X. If the size of X is 4, then the high word is returned. If the size is
2 then the high byte is returned.
<var>Hi</var> cannot be invoked on types of size 1, such as byte or char.
</descr>
<errors>
None
</errors>
<seealso>
<link id="Lo"/>
</seealso>
<example file="refex/ex31"/>
</element>



<element name="High">
<short>Return highest index of open array or enumerated</short>
<descr>
<p>
The return value of <var>High</var> depends on it's argument:
</p>
<ol>
<li> If the argument is an ordinal type, <var>High</var> returns the highest
 value in the range of the given ordinal type.
</li>
<li> If the argument is an array type or an array type variable then
<var>High</var> returns the highest possible value of it's index.
</li>
<li> If the argument is an open array identifier in a function or
procedure, then <var>High</var> returns the highest index of the array, as if the
array has a zero-based index.
</li>
</ol>
<p>
The return type is always the same type as the type of the argument
(This can lead to some nasty surprises !).
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Low"/>
<link id="Ord"/>
<link id="Pred"/>
<link id="Succ"/>
</seealso>
<example file="refex/ex80"/>
</element>



<element name="Inc">
<short>Increase value of integer variable</short>
<descr>
<var>Inc</var> increases the value of <var>X</var> with <var>Increment</var>.
If <var>Increment</var> isn't specified, then 1 is taken as a default.
</descr>
<errors>
If range checking is on, then A range check can occur, or an overflow
error, when an attempt is made to increase <var>X</var> over its maximum value.
</errors>
<seealso>
<link id="Dec"/>
</seealso>
<example file="refex/ex32"/>
</element>



<element name="Include">
<short>Include element in set if it was not yet present.</short>
<descr>
<p>
<var>Include</var> includes <var>E</var> in the set <var>S</var> if it is
not yet part of the set. E should be of the same type as the base type
of the set <var>S</var>.
</p>
<p>
Thus, the two following statements do the same thing:
</p>
<code>
S:=S+[E];
Include(S,E);
</code>
<p>
For an example, see <link id="Exclude"/>
</p>
</descr>
<errors>
If the type of the element <var>E</var> is not equal to the base type of the
set <var>S</var>, the compiler will generate an error.
</errors>
<seealso>
<link id="Exclude"/>
</seealso>
</element>


<element name="IndexByte">
<short>Search for a byte in a memory range.</short>
<descr>
<var>IndexByte</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the byte <var>b</var> and returns it's position if it found one.
If <var>b</var> is not found then -1 is returned.

The position is zero-based.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexChar"/>
<link id="IndexDWord"/>
<link id="IndexWord"/>
<link id="CompareByte"/>
</seealso>
<example file="refex/ex105"/>
</element>



<element name="IndexChar">
<short>Search for a character in a memory range.</short>
<descr>
<var>IndexChar</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the character <var>b</var> and returns it's position if it found one.
If <var>b</var> is not found then -1 is returned.

The position is zero-based. The <var>IndexChar0</var> variant stops looking if
a null character is found, and returns -1 in that case.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexDWord"/>
<link id="IndexWord"/>
<link id="CompareChar"/>
</seealso>
<example file="refex/ex108"/>
</element>



<element name="IndexDWord">
<short>Search for a DWord value in a memory range.</short>
<descr>
<var>IndexChar</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the DWord <var>DW</var> and returns it's position if it found one.
If <var>DW</var> is not found then -1 is returned.

The position is zero-based.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexChar"/>
<link id="IndexWord"/>
<link id="CompareDWord"/>
</seealso>
<example file="refex/ex106"/>
</element>



<element name="IndexWord">
<short>Search for a WORD value in a memory range.</short>
<descr>
<var>IndexChar</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the Word <var>W</var> and returns it's position if it found one.
If <var>W</var> is not found then -1 is returned.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexDWord"/>
<link id="IndexChar"/>
<link id="CompareWord"/>
</seealso>
<example file="refex/ex107"/>
</element>



<element name="Insert">
<short>Insert one string in another.</short>
<descr>
<var>Insert</var> inserts string <var>Source</var> in string <var>S</var>, at position
<var>Index</var>, shifting all characters after <var>Index</var> to the right. The
resulting string is truncated at 255 characters, if needed. (i.e. for
shortstrings)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Delete"/>
<link id="Copy"/>
<link id="Pos"/>
</seealso>
<example file="refex/ex33"/>
</element>



<element name="IsMemoryManagerSet">
<short>Is the memory manager set</short>
<descr>
<var>IsMemoryManagerSet</var> will return <var>True</var> if the memory manager has
been set to another value than the system heap manager, it will return
<var>False</var> otherwise.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetMemoryManager"/>
<link id="GetMemoryManager"/>
</seealso>
</element>

<element name="Int">
<short>Calculate integer part of floating point value.</short>
<descr>
<var>Int</var> returns the integer part of any Real <var>X</var>, as a Real.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Frac"/>
<link id="Round"/>
</seealso>
<example file="refex/ex34"/>
</element>



<element name="IOresult">
<short>Return result of last file IO operation</short>
<descr>
<p>
IOresult contains the result of any input/output call, when the
<var>{\$i-}</var> compiler directive is active, disabling IO checking.
When the flag is read, it is reset to zero.
If <var>IOresult</var> is zero, the operation completed successfully. If
non-zero, an error occurred. The following errors can occur:
</p>
<p>
dos errors :
</p>
<dl><dt>2</dt><dd> File not found.</dd>
<dt>3</dt><dd> Path not found.</dd>
<dt>4</dt><dd> Too many open files.</dd>
<dt>5</dt><dd> Access denied.</dd>
<dt>6</dt><dd> Invalid file handle.</dd>
<dt>12</dt><dd> Invalid file-access mode.</dd>
<dt>15</dt><dd> Invalid disk number.</dd>
<dt>16</dt><dd> Cannot remove current directory.</dd>
<dt>17</dt><dd> Cannot rename across volumes.</dd>
</dl>
<p>
I/O errors :
</p>
<dl>
<dt>100</dt><dd> Error when reading from disk.</dd>
<dt>101</dt><dd> Error when writing to disk.</dd>
<dt>102</dt><dd> File not assigned.</dd>
<dt>103</dt><dd> File not open.</dd>
<dt>104</dt><dd> File not opened for input.</dd>
<dt>105</dt><dd> File not opened for output.</dd>
<dt>106</dt><dd> Invalid number.</dd>
</dl>
<p>
Fatal errors :
</p>
<dl>
<dt>150</dt><dd> Disk is write protected.</dd>
<dt>151</dt><dd> Unknown device.</dd>
<dt>152</dt><dd> Drive not ready.</dd>
<dt>153</dt><dd> Unknown command.</dd>
<dt>154</dt><dd> CRC check failed.</dd>
<dt>155</dt><dd> Invalid drive specified..</dd>
<dt>156</dt><dd> Seek error on disk.</dd>
<dt>157</dt><dd> Invalid media type.</dd>
<dt>158</dt><dd> Sector not found.</dd>
<dt>159</dt><dd> Printer out of paper.</dd>
<dt>160</dt><dd> Error when writing to device.</dd>
<dt>161</dt><dd> Error when reading from device.</dd>
<dt>162</dt><dd> Hardware failure.</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
All I/O functions.
</seealso>
<example file="refex/ex35"/>
</element>



<element name="Length">
<short>Calculate length of a string.</short>
<descr>
<var>Length</var> returns the length of the string <var>S</var>, which is limited
to 255 for shortstrings. If the strings <var>S</var> is empty, 0 is returned.

<em> Note:</em> The length of the string <var>S</var> is stored in <var>S[0]</var> for
shortstrings only. The <var>Length</var> fuction should always be used on 
ansistrings and widestrings.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="Pos"/>
</seealso>
<example file="refex/ex36"/>
</element>



<element name="Ln">
<short>Calculate logarithm</short>
<descr>
<var>Ln</var> returns the natural logarithm of the Real parameter <var>X</var>.
<var>X</var> must be positive.
</descr>
<errors>
An run-time error will occur when <var>X</var> is negative.
</errors>
<seealso>
<link id="Exp"/>
<link id="Power"/>
</seealso>
<example file="refex/ex37"/>
</element>



<element name="Lo">
<short>Return low byte/word of value.</short>
<descr>
<var>Lo</var> returns the low byte of its argument if this is of type
<var>Integer</var> or
<var>Word</var>. It returns the low word of its argument if this is of type
<var>Longint</var> or <var>Cardinal</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Ord"/>
<link id="Chr"/>
<link id="Hi"/>
</seealso>
<example file="refex/ex38"/>
</element>



<element name="LongJmp">
<short>Jump to address.</short>
<descr>
<p>
<var>LongJmp</var> jumps to the adress in the <var>env</var> <var>jmp_buf</var>,
and restores the registers that were stored in it at the corresponding
<link id="SetJmp"/> call.
In effect, program flow will continue at the <var>SetJmp</var> call, which will
return <var>value</var> instead of 0. If a <var>value</var> equal to zero is passed,
it will be converted to 1 before passing it on. The call will not return, so it must be
used with extreme care.
This can be used for error recovery, for instance when a segmentation fault
occurred.
</p>
<p>
For an example, see <link id="SetJmp"/>
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetJmp"/>
</seealso>
</element>

<element name="Low">
<short>Return lowest index of open array or enumerated</short>
<descr>
<p>
 The return value of <var>Low</var> depends on it's argument:
</p>
<ol>
<li> If the argument is an ordinal type, <var>Low</var> returns the lowest
value in the range of the given ordinal type.
</li>
<li> If the argument is an array type or an array type variable then
<var>Low</var> returns the lowest possible value of it's index.
</li>
</ol>
<p>
The return type is always the same type as the type of the argument.
</p>
<p>
for an example, see <link id="High"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="High"/>
<link id="Ord"/>
<link id="Pred"/>
<link id="Succ"/>
</seealso>
</element>

<element name="Lowercase">
<short>Return lowercase version of a string.</short>
<descr>
<var>Lowercase</var> returns the lowercase version of its argument <var>C</var>.
If its argument is a string, then the complete string is converted to
lowercase. The type of the returned value is the same as the type of the
argument.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Upcase"/>
</seealso>
<example file="refex/ex73"/>
</element>




<element name="Mkdir">
<short>Create a new directory.</short>
<descr>
<p>
<var>Mkdir</var> creates a new  directory <var>S</var>.
</p>
<p>
For an example, see <link id="Rmdir"/>.
</p>
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Chdir"/>
<link id="Rmdir"/>
</seealso>
</element>

<element name="Move">
<short>Move data from one location in memory to another</short>
<descr>
<var>Move</var> moves <var>Count</var> bytes from <var>Source</var> to <var>Dest</var>.
</descr>
<errors>
If either <var>Dest</var> or <var>Source</var> is outside the accessible memory for
the process, then a run-time error will be generated.
</errors>
<seealso>
<link id="Fillword"/>
<link id="Fillchar"/>
</seealso>
<example file="refex/ex42"/>
</element>



<element name="MoveChar0">
<short>Move data till first zero character</short>
<descr>
<var>MoveChar0</var> moves <var>Count</var> bytes from <var>Src</var> to <var>Dest</var>, and
stops moving if a zero character is found.
</descr>
<errors>
No checking is done to see if <var>Count</var> stays within the memory allocated
to the process.
</errors>
<seealso>
<link id="Move"/>
</seealso>
<example file="refex/ex109"/>
</element>



<element name="New">
<short>Dynamically allocate memory for variable</short>
<descr>
<p>
<var>New</var> allocates a new instance of the type pointed to by <var>P</var>, and
puts the address in <var>P</var>.
If P is an object, then it is possible to
specify the name of the constructor with which the instance will be created.
</p>
<p>
For an example, see <link id="Dispose"/>.
</p>
</descr>
<errors>
If not enough memory is available, <var>Nil</var> will be returned.
</errors>
<seealso>
<link id="Dispose"/>
<link id="Freemem"/>
<link id="Getmem"/>
</seealso>
</element>

<element name="Odd">
<short>Is a value odd or even ?</short>
<descr>
<var>Odd</var> returns <var>True</var> if <var>X</var> is odd, or <var>False</var> otherwise.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Abs"/>
<link id="Ord"/>
</seealso>
<example file="refex/ex43"/>
</element>



<element name="OctStr">
<short>Convert integer to a string with octal representation.</short>
<descr>
<var>OctStr</var> returns a string with the octal representation
of <var>Value</var>. The string has exactly <var>cnt</var> charaters.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Str"/>
<link id="Val"/>
<link id="BinStr"/>
<link id="HexStr"/>
</seealso>
<example file="refex/ex112"/>
</element>



<element name="Ofs">
<short>Return offset of a variable.</short>
<descr>
<var>Ofs</var> returns the offset of the address of a variable.
This function is only supported for compatibility. In Free Pascal, it
returns always the complete address of the variable, since Free Pascal is a 32 bit
compiler.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="DSeg"/>
<link id="CSeg"/>
<link id="Seg"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex44"/>
</element>



<element name="Ord">
<short>Return ordinal value of an ordinal type.</short>
<descr>
<p>
<var>Ord</var> returns the Ordinal value of a ordinal-type variable <var>X</var>.
</p>
<p>
Historical note:
</p><p>
Originally, Pascal did not have typecasts and ord was a necessary function in
order to do certain operations on non-integer ordinal types. With the arrival of
typecasting a generic approach became possible, making ord mostly obselete.
However ord is not considered deprecated and remains in wide use today.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Chr"/>
<link id="Succ"/>
<link id="Pred"/>
<link id="High"/>
<link id="Low"/>
</seealso>
<example file="refex/ex45"/>
</element>



<element name="Paramcount">
<short>Return number of command-line parameters passed to the program.</short>
<descr>
<var>Paramcount</var> returns the number of command-line arguments. If no
arguments were given to the running program, <var>0</var> is returned.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="Paramstr"/>
</seealso>
<example file="refex/ex46"/>
</element>



<element name="Paramstr">
<short>Return value of a command-line argument.</short>
<descr>
<p>
<var>Paramstr</var> returns the <var>L</var>-th command-line argument. <var>L</var> must
be between <var>0</var> and <var>Paramcount</var>, these values included.
The zeroth argument is the path and file name with which the program was
started.
</p>
<p>
The command-line parameters will be truncated to a length of 255,
even though the operating system may support bigger command-lines.
The <var>Objpas</var> unit (used in <var>objfpc</var> or <var>delphi</var> mode) define versions
of <var>Paramstr</var> which return the full-length command-line arguments.
</p>
<p>
In the interrest of portability, the paramstr function behaves the same on all
operating systems: like the original paramstr function in Turbo Pascal.
This means even on Unix, paramstr(0) returns the full path to the program
executable.

When the complete Unix command-line must be accessed, the <var>argv</var> pointer
should be used to retrieve the real values of the command-line parameters.
</p>
<p>
For an example, see <link id="Paramcount"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Paramcount"/>
</seealso>
</element>

<element name="Pi">
<short>Return the value of PI.</short>
<descr>
<var>Pi</var> returns the value of Pi (3.1415926535897932385).
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Cos"/>
<link id="Sin"/>
</seealso>
<example file="refex/ex47"/>
</element>



<element name="Pos">
<short>Search for substring in a string.</short>
<descr>
<var>Pos</var> returns the index of <var>Substr</var> in <var>S</var>, if <var>S</var> contains
<var>Substr</var>. In case <var>Substr</var> isn't found, <var>0</var> is returned.
The search is case-sensitive.
</descr>
<errors>
None
</errors>
<seealso>
<link id="Length"/>
<link id="Copy"/>
<link id="Delete"/>
<link id="Insert"/>
</seealso>
<example file="refex/ex48"/>
</element>



<element name="Power">
<short>Raise float to integer power</short>
<descr>
<p>
<var>Power</var> returns the value of <var>base</var> to the power <var>expon</var>.
<var>Base</var> and <var>expon</var> can be of type Longint, in which case the
result will also be a Longint.
</p>
<p>
The function actually returns <var>Exp(expon*Ln(base))</var>
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Exp"/>
<link id="Ln"/>
</seealso>
<example file="refex/ex78"/>
</element>



<element name="Pred">
<short>Return previous element for an ordinal type.</short>
<descr>
<p>
<var>Pred</var> returns the element that precedes the element that was passed
to it. If it is applied to the first value of the ordinal type, and the
program was compiled with range checking on (\var{\{\$R+\}}, then a run-time
error will be generated.
</p>
<p>
for an example, see <link id="Ord"/>
</p>
</descr>
<errors>
Run-time error 201 is generated when the result is out of
range.
</errors>
<seealso>
<link id="Ord"/>
<link id="Pred"/>
<link id="High"/>
<link id="Low"/>
</seealso>
</element>


<element name="Ptr">
<short>Combine segment and offset to pointer</short>
<descr>
<p>
<var>Ptr</var> returns a pointer, pointing to the address specified by
segment <var>Sel</var> and offset <var>Off</var>.
</p>
<remark>
<ol>
<li> In the 32-bit flat-memory model supported by Free Pascal, this
function is obsolete.
</li>
<li> The returned address is simply the offset.
</li>
</ol>
</remark>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Addr"/>
</seealso>
<example file="refex/ex59"/>
</element>



<element name="Random">
<short>Generate random number</short>
<descr>
<var>Random</var> returns a random number larger or equal to <var>0</var> and
strictly less than <var>L</var>.
If the argument <var>L</var> is omitted, a Real number between 0 and 1 is returned.
(0 included, 1 excluded)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Randomize"/>
</seealso>
<example file="refex/ex49"/>
</element>



<element name="Randomize">
<short>Initialize random number generator</short>
<descr>
<p>
<var>Randomize</var> initializes the random number generator of Free Pascal, by giving
a value to <var>Randseed</var>, calculated with the system clock.
</p>
<p>
For an example, see <link id="Random"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Random"/>
</seealso>
</element>

<element name="Read">
<short>Read from a text file into variable</short>
<descr>
<var>Read</var> reads one or more values from a file <var>F</var>, and stores the
result in <var>V1</var>, <var>V2</var>, etc.; If no file <var>F</var> is specified, then
standard input is read.
If <var>F</var> is of type <var>Text</var>, then the variables <var>V1, V2</var> etc. must be
of type <var>Char</var>, <var>Integer</var>, <var>Real</var>, <var>String</var> or <var>PChar</var>.
If <var>F</var> is a typed file, then each of the variables must be of the type
specified in the declaration of <var>F</var>. Untyped files are not allowed as an
argument.
</descr>
<errors>
If no data is available, a run-time error is generated. This behavior can
be controlled with the \var{\{\$i\}} compiler switch.
</errors>
<seealso>
<link id="Readln"/>
<link id="Blockread"/>
<link id="Write"/>
<link id="Blockwrite"/>
</seealso>
<example file="refex/ex50"/>
</element>



<element name="Readln">
<short>Read from a text file into variable and goto next line</short>
<descr>
<p>
<var>Read</var> reads one or more values from a file <var>F</var>, and stores the
result in <var>V1</var>, <var>V2</var>, etc. After that it goes to the next line in
the file. The end of the line is marked by the <var>LineEnding</var>
character sequence (which is platform dependent). The end-of-line marker is
not considered part of the line and is ignored.
</p>
<p>
If no file <var>F</var> is specified, then standard input is read.
The variables <var>V1, V2</var> etc. must be of type <var>Char</var>, <var>Integer</var>,
<var>Real</var>, <var>String</var> or <var>PChar</var>.
</p>
<p>
For an example, see <link id="Read"/>.
</p>
</descr>
<errors>
If no data is available, a run-time error is generated. This behavior can
be controlled with the \var{\{\$i\}} compiler switch.
</errors>
<seealso>
<link id="Read"/>
<link id="Blockread"/>
<link id="Write"/>
<link id="Blockwrite"/>
</seealso>
</element>


<element name="Real2Double">
<short>Convert Turbo Pascal style real to double.</short>
<descr>
<p>
The <var>Real2Double</var> function converts a Turbo Pascal style real (6 bytes long) to
a native Free Pascal double type. It can be used e.g. to read old binary TP files with
FPC and convert them to Free Pacal binary files.
</p>
<p>
Note that the assignment operator has been overloaded so a <var>Real48</var> type
can be assigned directly to a double or extended.
</p>
</descr>
<errors>
None.
</errors>
<seealso></seealso>
<example file="refex/ex110"/>
</element>



<element name="Rename">
<short>Rename file on disk</short>
<descr>
<var>Rename</var> changes the name of the assigned file <var>F</var> to <var>S</var>.
<var>F</var>
must be assigned, but not opened.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Erase"/>
</seealso>
<example file="refex/ex77"/>
</element>



<element name="Reset">
<short>Open file for reading</short>
<descr>
<var>Reset</var> opens a file <var>F</var> for reading. <var>F</var> can be any file type.
If <var>F</var> is a text file, or refers to standard I/O (e.g : '') then it is 
opened read-only, otherwise it is opened using the mode specified in 
<var>filemode</var>.

If <var>F</var> is an untyped file, the record size can be specified in
the optional parameter <var>L</var>. A default value of 128 is used.

File sharing is not taken into account when calling <var>Reset</var>.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Rewrite"/>
<link id="Assign"/>
<link id="Close"/>
<link id="Append"/>
</seealso>
<example file="refex/ex51"/>
</element>



<element name="Rewrite">
<short>Open file for writing</short>
<descr>
<var>Rewrite</var> opens a file <var>F</var> for writing. <var>F</var> can be any file type.
If <var>F</var> is an untyped or typed file, then it is opened for reading and
writing. If <var>F</var> is an untyped file, the record size can be specified in
the optional parameter <var>L</var>. Default a value of 128 is used.
if <var>Rewrite</var> finds a file with the same name as <var>F</var>, this file is
truncated to length <var>0</var>. If it doesn't find such a file, a new file is
created.

Contrary to Turbo Pascal, Free Pascal opens the file with mode <var>fmoutput</var>. If it should
be opened in <var>fminout</var> mode, an extra call to <link id="Reset"/> is needed.

File sharing is not taken into account when calling <var>Rewrite</var>.

</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Reset"/>
<link id="Assign"/>
<link id="Close"/>
<link id="Flush"/>
<link id="Append"/>
</seealso>
<example file="refex/ex52"/>
</element>



<element name="Rmdir">
<short>Remove directory when empty.</short>
<descr>
<var>Rmdir</var> removes the directory <var>S</var>.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Chdir"/>
<link id="Mkdir"/>
</seealso>
<example file="refex/ex53"/>
</element>



<element name="Round">
<short>Round floating point value to nearest integer number.</short>
<descr>
<p>
<var>Round</var> rounds <var>X</var> to the closest integer, which may be bigger or
smaller than <var>X</var>.
</p>
<p>
In the case of <var>.5</var>, the algorithm uses "banker's rounding": 
<var>.5</var> values are always rounded towards the even number.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Frac"/>
<link id="Int"/>
<link id="Trunc"/>
</seealso>
<example file="refex/ex54"/>
</element>



<element name="Runerror">
<short>Generate a run-time error.</short>
<descr>
<var>Runerror</var> stops the execution of the program, and generates a
run-time error <var>ErrorCode</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Exit"/>
<link id="Halt"/>
</seealso>
<example file="refex/ex55"/>
</element>



<element name="Seek">
<short>Set file position</short>
<descr>
<var>Seek</var> sets the file-pointer for file <var>F</var> to record Nr. <var>Count</var>.
The first record in a file has <var>Count=0</var>. F can be any file type, except
<var>Text</var>. If <var>F</var> is an untyped file, with no record size specified in
<link id="Reset"/> or <link id="Rewrite"/>, 128 is assumed.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Eof"/>
<link id="SeekEof"/>
<link id="SeekEoln"/>
</seealso>
<example file="refex/ex56"/>
</element>



<element name="SeekEof">
<short>Set file position to end of file</short>
<descr>
<var>SeekEof</var> returns <var>True</var> is the file-pointer is at the end of the
file. It ignores all whitespace.
Calling this function has the effect that the file-position is advanced
until the first non-whitespace character or the end-of-file marker is
reached.
If the end-of-file marker is reached, <var>True</var> is returned. Otherwise,
False is returned.
If the parameter <var>F</var> is omitted, standard <var>Input</var> is assumed.

</descr>
<errors>
A run-time error is generated if the file <var>F</var> isn't opened.
</errors>
<seealso>
<link id="Eof"/>
<link id="SeekEoln"/>
<link id="Seek"/>
</seealso>
<example file="refex/ex57"/>
</element>



<element name="SeekEoln">
<short>Set file position to end of line</short>
<descr>
<var>SeekEoln</var> returns <var>True</var> is the file-pointer is at the end of the
current line. It ignores all whitespace.
Calling this function has the effect that the file-position is advanced
until the first non-whitespace character or the end-of-line marker is
reached.
If the end-of-line marker is reached, <var>True</var> is returned. Otherwise,
False is returned.
The end-of-line marker is defined as <var>#10</var>, the LineFeed character.
If the parameter <var>F</var> is omitted, standard <var>Input</var> is assumed.
</descr>
<errors>
A run-time error is generated if the file <var>F</var> isn't opened.
</errors>
<seealso>
<link id="Eof"/>
<link id="SeekEof"/>
<link id="Seek"/>
</seealso>
<example file="refex/ex58"/>
</element>



<element name="Seg">
<short>Return segment</short>
<descr>
<var>Seg</var> returns the segment of the address of a variable.
This function is only supported for compatibility. In Free Pascal, it
returns always 0, since Free Pascal uses a flat 32/64 bit
memory model. In such a memory model segments have no meaning.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="DSeg"/>
<link id="CSeg"/>
<link id="Ofs"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex60"/>
</element>



<element name="SetMemoryManager">
<short>Set a memory manager</short>
<descr>
<p>
<var>SetMemoryManager</var> sets the current memory manager record to
<var>MemMgr</var>.
</p>
<p>
For an example, see \progref.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetMemoryManager"/>
<link id="IsMemoryManagerSet"/>
</seealso>
</element>


<element name="SetJmp">
<short>Save current execution point.</short>
<descr>
<var>SetJmp</var> fills <var>env</var> with the necessary data for a jump back to the
point where it was called. It returns zero if called in this way.
If the function returns nonzero, then it means that a call to <link id="LongJmp"/>
with <var>env</var> as an argument was made somewhere in the program.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="LongJmp"/>
</seealso>
<example file="refex/ex79"/>
</element>




<element name="SetLength">
<short>Set length of a string.</short>
<descr>
<var>SetLength</var> sets the length of the string <var>S</var> to <var>Len</var>. <var>S</var>
can be an ansistring, a short string or a widestring.
For <var>ShortStrings</var>, <var>Len</var> can maximally be 255. For <var>AnsiStrings</var>
it can have any value. For <var>AnsiString</var> strings, <var>SetLength</var> {\em
must} be used to set the length of the string.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Length"/>
</seealso>
<example file="refex/ex85"/>
</element>



<element name="SetString">
<short>Set length of a string and copy buffer.</short>
<descr>
<var>SetString</var> sets the length of the string <var>S</var> to <var>Len</var> and
if <var>Buf</var> is non-nil, copies <var>Len</var> characters from <var>Buf</var> 
into <var>S</var>.  <var>S</var> can be an ansistring, a short string or a widestring.
For <var>ShortStrings</var>, <var>Len</var> can maximally be 255. 
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetLength"/>
</seealso>
</element>



<element name="SetTextBuf">
<short>Set size of text file internal buffer</short>
<descr>
<p>
<var>SetTextBuf</var> assigns an I/O buffer to a text file. The new buffer is
located at <var>Buf</var> and is <var>Size</var> bytes long. If <var>Size</var> is omitted,
then <var>SizeOf(Buf)</var> is assumed.
The standard buffer of any text file is 128 bytes long. For heavy I/O
operations this may prove too slow. The <var>SetTextBuf</var> procedure allows
to set a bigger buffer for the I/O of the application, thus reducing the number of
system calls, and thus reducing the load on the system resources.
The maximum size of the newly assigned buffer is 65355 bytes.
</p>
<remark>
<ul>
<li> Never assign a new buffer to an opened file. A
new buffer can be assigned immediately after a call
to <link id="Rewrite"/>, <link id="Reset"/> or
<var>Append</var>, but not after the file was read from/written to. This may cause
loss of data. If a new buffer must be assigned after read/write
operations have been performed, the file should be flushed first.
This will ensure that the current buffer is emptied.
</li>
<li> Take care that the assigned buffer is always valid. If a local variable is
assigned as a buffer, then after the program exits the local program block,
the buffer will no longer be valid, and stack problems may occur.
</li>
</ul>
</remark>
</descr>
<errors>
No checking on <var>Size</var> is done.
</errors>
<seealso>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
<link id="Append"/>
</seealso>
<example file="refex/ex61"/>
</element>



<element name="Sin">
<short>Calculate sine of angle</short>
<descr>
<var>Sin</var> returns the sine of its argument <var>X</var>, where <var>X</var> is an
angle in radians.

If the absolute value of the argument is larger than 2^63, then the
result is undefined.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Cos"/>
<link id="Pi"/>
<link id="Exp"/>
<link id="Ln"/>
</seealso>
<example file="refex/ex62"/>
</element>



<element name="SizeOf">
<short>Return size of a variable or type.</short>
<descr>
<p>
<var>SizeOf</var> returns the size, in bytes, of any variable or type-identifier.
</p>
<remark>
This isn't really a RTL function. Its result is calculated at
compile-time, and hard-coded in the executable.
</remark>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Addr"/>
</seealso>
<example file="refex/ex63"/>
</element>



<element name="Sptr">
<short>Return current stack pointer</short>
<descr>
<var>Sptr</var> returns the current stack pointer.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="SSeg"/>
</seealso>
<example file="refex/ex64"/>
</element>



<element name="Sqr">
<short>Calculate the square of a value.</short>
<descr>
<var>Sqr</var> returns the square of its argument <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Sqrt"/>
<link id="Ln"/>
<link id="Exp"/>
</seealso>
<example file="refex/ex65"/>
</element>



<element name="Sqrt">
<short>Calculate the square root of a value</short>
<descr>
<var>Sqrt</var> returns the square root of its argument <var>X</var>, which must be
positive.
</descr>
<errors>
If <var>X</var> is negative, then a run-time error is generated.
</errors>
<seealso>
<link id="Sqr"/>
<link id="Ln"/>
<link id="Exp"/>
</seealso>
<example file="refex/ex66"/>
</element>



<element name="SSeg">
<short>Return stack segment register value.</short>
<descr>
 <var>SSeg</var> returns the Stack Segment. This function is only
 supported for compatibility reasons, as <var>Sptr</var> returns the
correct contents of the stackpointer.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Sptr"/>
</seealso>
<example file="refex/ex67"/>
</element>



<element name="Str">
<short>Convert a numerical value to a string.</short>
<descr>
<var>Str</var> returns a string which represents the value of X. X can be any
numerical type.
The optional <var>NumPLaces</var> and <var>Decimals</var> specifiers control the
formatting of the string.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Val"/>
</seealso>
<example file="refex/ex68"/>
</element>



<element name="StringOfChar">
<short>Return a string consisting of 1 character repeated N times.</short>
<descr>
<p>
<var>StringOfChar</var> creates a new String of length <var>l</var> and fills
it with the character <var>c</var>.
</p>
<p>
It is equivalent to  the following calls:
</p>
<code>
SetLength(StringOfChar,l);
FillChar(Pointer(StringOfChar)^,Length(StringOfChar),c);
</code>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetLength"/>
</seealso>
<example file="refex/ex97"/>
</element>



<element name="Succ">
<short>Return next element of ordinal type.</short>
<descr>
<p>
<var>Succ</var> returns the element that succeeds the element that was passed
to it. If it is applied to the last value of the ordinal type, and the
program was compiled with range checking on (\var{\{\$R+\}}), then a run-time
error will be generated.
</p>
<p>
for an example, see <link id="Ord"/>.
</p>
</descr>
<errors>
Run-time error 201 is generated when the result is out of
range.
</errors>
<seealso>
<link id="Ord"/>
<link id="Pred"/>
<link id="High"/>
<link id="Low"/>
</seealso>
</element>

<element name="Swap">
<short>Swap high and low bytes/words of a variable</short>
<descr>
<var>Swap</var> swaps the high and low order bytes of <var>X</var> if <var>X</var> is of
type <var>Word</var> or <var>Integer</var>, or swaps the high and low order words of
<var>X</var> if <var>X</var> is of type <var>Longint</var> or <var>Cardinal</var>.
The return type is the type of <var>X</var>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Lo"/>
<link id="Hi"/>
</seealso>
<example file="refex/ex69"/>
</element>



<element name="Trunc">
<short>Truncate a floating point value.</short>
<descr>
<var>Trunc</var> returns the integer part of <var>X</var>,
which is always smaller than (or equal to) <var>X</var> in absolute value.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Frac"/>
<link id="Int"/>
<link id="Round"/>
</seealso>
<example file="refex/ex70"/>
</element>



<element name="Truncate">
<short>Truncate the file at position</short>
<descr>
<var>Truncate</var> truncates the (opened) file <var>F</var> at the current file
position.

</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Append"/>
<link id="Filepos"/>,
<link id="Seek"/>
</seealso>
<example file="refex/ex71"/>
</element>



<element name="Upcase">
<short>Convert a string to all uppercase.</short>
<descr>
<var>Upcase</var> returns the uppercase version of its argument <var>C</var>.
If its argument is a string, then the complete string is converted to
uppercase. The type of the returned value is the same as the type of the
argument.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Lowercase"/>
</seealso>
<example file="refex/ex72"/>
</element>



<element name="Val">
<short>Calculate numerical value of a string.</short>
<descr>
<var>Val</var> converts the value represented in the string <var>S</var> to a numerical
value, and stores this value in the variable <var>V</var>, which
can be of type <var>Longint</var>, <var>Real</var> and <var>Byte</var>.
If the conversion isn't succesfull, then the parameter <var>Code</var> contains
the index of the character in <var>S</var> which prevented the conversion.
The string <var>S</var> is allowed to contain spaces in the beginning.

The string <var>S</var> can contain a number in decimal, hexadecimal, binary
or octal format, as described in the language reference.

</descr>
<errors>
If the conversion doesn't succeed, the value of <var>Code</var> indicates the
position where the conversion went wrong.
</errors>
<seealso>
<link id="Str"/>
</seealso>
<example file="refex/ex74"/>
</element>



<element name="Write">
<short>Write variable to a text file</short>
<descr>
<var>Write</var> writes the contents of the variables <var>V1</var>, <var>V2</var> etc. to
the file <var>F</var>. <var>F</var> can be a typed file, or a <var>Text</var> file.
If <var>F</var> is a typed file, then the variables <var>V1</var>, <var>V2</var> etc. must
be of the same type as the type in the declaration of <var>F</var>. Untyped files
are not allowed.
If the parameter <var>F</var> is omitted, standard output is assumed.
If <var>F</var> is of type <var>Text</var>, then the necessary conversions are done
such that the output of the variables is in human-readable format.
This conversion is done for all numerical types. Strings are printed exactly
as they are in memory, as well as <var>PChar</var> types.
The format of the numerical conversions can be influenced through
the following modifiers:
<var> OutputVariable : NumChars [: Decimals ]  </var>
This will print the value of <var>OutputVariable</var> with a minimum of
<var>NumChars</var> characters, from which <var>Decimals</var> are reserved for the
decimals. If the number cannot be represented with <var>NumChars</var> characters,
<var>NumChars</var> will be increased, until the representation fits. If the
representation requires less than <var>NumChars</var> characters then the output
is filled up with spaces, to the left of the generated string, thus
resulting in a right-aligned representation.
If no formatting is specified, then the number is written using its natural
length, with nothing in front of it if it's positive, and a minus sign if
it's negative.
Real numbers are, by default, written in scientific notation.
</descr>
<errors>
If an error occurs, a run-time error is generated. This behavior can be
controlled with the \var{\{\$i\}} switch.
</errors>
<seealso>
<link id="WriteLn"/>
<link id="Read"/>
<link id="Readln"/>
<link id="Blockwrite"/>
</seealso>
</element>

<element name="WriteLn">
<short>Write variable to a text file and append newline</short>
<descr>
<p>
<var>WriteLn</var> does the same as <link id="Write"/> for text files, and emits a
Carriage Return - LineFeed character pair after that.
If the parameter <var>F</var> is omitted, standard output is assumed.
If no variables are specified, a Carriage Return - LineFeed character pair
is emitted, resulting in a new line in the file <var>F</var>.
</p>
<remark>
Under linux and unix, the Carriage Return character is omitted, as
customary in Unix environments.
</remark>
</descr>
<errors>
If an error occurs, a run-time error is generated. This behavior can be
controlled with the \var{\{\$i\}} switch.
</errors>
<seealso>
<link id="Write"/>
<link id="Read"/>
<link id="Readln"/>
<link id="Blockwrite"/>
</seealso>
<example file="refex/ex75"/>
</element>

<!-- range type Visibility: default -->
<element name="ShortInt">
<short>A signed 8-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="SmallInt">
<short>A signed 16-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="Longint">
<short>A signed 32-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="Byte">
<short>An unsigned 8-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="Word">
<short>An unsigned 16-bits integer</short>
</element>

<!-- alias type Visibility: default -->
<element name="DWord">
<short>An unsigned 32-bits integer</short>
</element>

<!-- alias type Visibility: default -->
<element name="Cardinal">
<short>An unsigned 32-bits integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="Integer">
<short>A signed 16-bits integer</short>
<descr>
The system unit defines <var>Integer</var> as a signed 16-bit integer.
But when <var>DELPHI</var> or <var>OBJFPC</var> mode are active, then
the <file>objpas</file> unit redefines <var>Integer</var> as a 32-bit
integer.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="PChar">
<short>Pointer to null-terminated string.</short>
<descr>
Or the same as a pointer to an array of char. See the reference manual for
more information about this type.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="PPChar">
<short>Pointer to an array of pointers to null-terminated strings.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TAnsiChar">
<short>Alias for 1-byte sized char.</short>
</element>

<!-- alias type Visibility: default -->
<element name="AnsiChar">
<short>Alias for 1-byte sized char.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PAnsiChar">
<short>Alias for <link id="PChar"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PPAnsiChar">
<short>Alias for <link id="PPChar"/> type.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="UCS4Char">
<short>UCS unicode character (unsigned 32 bit word)</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCS4Char">
<short>Pointer to <link id="UCS4Char"/></short>
</element>

<!-- array type Visibility: default -->
<element name="TUCS4CharArray">
<short>Array of <link id="UCS4Char"/> characters.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCS4CharArray">
<short>Pointer to array of <link id="UCS4Char"/> characters.</short>
</element>

<!-- array type Visibility: default -->
<element name="UCS4String">
<short>String of <link id="UCS4Char"/> characters.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="UTF8String">
<short>UTF-8 unicode (ansi) string.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUTF8String">
<short>Pointer to <link id="UTF8String"/></short>
</element>

<!-- alias type Visibility: default -->
<element name="Currency">
<short>Currency type.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="HRESULT">
<short>32-Bit signed integer.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="TDateTime">
<short>Encoded Date-Time type.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="Error">
<short>32-bit signed integer.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSingle">
<short>Pointer to single-sized float value.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PDouble">
<short>Pointer to double-sized float value.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PCurrency">
<short>Pointer to currency type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PExtended">
<short>Pointer to extended-sized float value.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSmallInt">
<short>Pointer to <link id="smallint"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PShortInt">
<short>Pointer to <link id="shortint"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PInteger">
<short>Pointer to <link id="integer"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PByte">
<short>Pointer to <link id="byte"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PWord">
<short>Pointer to <link id="word"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PDWord">
<short>Pointer to <link id="DWord"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PLongWord">
<short>Pointer to <var>LongWord</var> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PLongint">
<short>Pointer to <link id="Longint"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PCardinal">
<short>Pointer to <link id="Cardinal"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PQWord">
<short>Pointer to <var>QWord</var> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PInt64">
<short>Pointer to <var>Int64</var> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPtrInt">
<short>Pointer to <link id="PtrInt"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSizeInt">
<short>Pointer to a <link id="SizeInt"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPointer">
<short>Pointer to a pointer type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPPointer">
<short>Pointer to a <link id="PPointer"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PBoolean">
<short>Pointer to a Boolean type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PWordBool">
<short>Pointer to a <var>WordBool</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PLongBool">
<short>Pointer to a <var>LongBool</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PShortString">
<short>Pointer to a shortstring type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PAnsiString">
<short>Pointer to an ansistring type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PDate">
<short>Pointer to a <link id="TDateTime"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PError">
<short>Pointer to an <link id="Error"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="WChar">
<short>Wide char (16-bit sized char)</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TTextLineBreakStyle">
<short>Text line break style. (end of line character)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTextLineBreakStyle.tlbsLF">
<short>Line-feed only (#10, unix style)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTextLineBreakStyle.tlbsCRLF">
<short>Carriage-return, line-feed (#13#30, Windows style)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTextLineBreakStyle.tlbsCR">
<short>Carriage-return (#13, Mac-OS style)</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TProcedure">
<short>Simple procedural type.</short>
</element>

<!-- constant Visibility: default -->
<element name="MaxSIntValue">
<short>Maximum String-size value.</short>
</element>

<!-- constant Visibility: default -->
<element name="MaxUIntValue">
<short>Maximum unsigned integer value.</short>
</element>

<!-- constant Visibility: default -->
<element name="maxLongint">
<short>Maximum longint value.</short>
</element>

<!-- constant Visibility: default -->
<element name="maxSmallint">
<short>Maximum smallint value.</short>
</element>

<!-- constant Visibility: default -->
<element name="maxint">
<short>Maximum integer value.</short>
</element>

<!-- array type Visibility: default -->
<element name="IntegerArray">
<short>Generic array of integer. </short>
</element>

<!-- pointer type Visibility: default -->
<element name="PIntegerArray">
<short>Pointer to <link id="IntegerArray"/> type</short>
</element>

<!-- array type Visibility: default -->
<element name="PointerArray">
<short>Generic pointer array.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPointerArray">
<short>Pointer to <link id="PointerArray"/> type</short>
</element>

<!-- array type Visibility: default -->
<element name="TBoundArray">
<short>Dynamic array of integer.</short>
</element>

<!-- array type Visibility: default -->
<element name="TPCharArray">
<short>Array of PChar</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPCharArray">
<short>Pointer to <link id="TPCharArray"/> type.</short>
</element>

<!-- constant Visibility: default -->
<element name="Max_Frame_Dump">
<short>Maximum number of frames to show in error frame dump.</short>
</element>

<!-- constant Visibility: default -->
<element name="ExitProc">
<short>Exit procedure pointer.</short>
</element>

<!-- constant Visibility: default -->
<element name="Erroraddr">
<short>Address where the last error occurred.</short>
</element>

<!-- constant Visibility: default -->
<element name="Errorcode">
<short>Last error code.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmClosed">
<short>File mode: File is closed.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmInput">
<short>File mode: File is open for reading.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmOutput">
<short>File mode: File is open for writing.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmInOut">
<short>File mode: File is open for reading and writing.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmAppend">
<short>File mode: File is open for writing, appending to the end.</short>
</element>

<!-- constant Visibility: default -->
<element name="ProcessID">
<short>Current process ID.</short>
</element>

<!-- constant Visibility: default -->
<element name="Filemode">
<short>Default file mode for untyped files.</short>
</element>

<!-- constant Visibility: default -->
<element name="CmdLine">
<short>Current command-line.</short>
<p><var>Cmdline</var> returns a pointer to the current command line. The ASCIIZ
string <var>cmdline</var> points to contains the command line, separated by
spaces.</p>
<p>
<var>Cmdline</var> can be implemented either by a variable, typed constant,
function or property. Because of this, you should not to write to it, or make
a pointer point to it.</p>
</element>

<!-- constant Visibility: default -->
<element name="IsMultiThread">
<short>Indicates whether more than one thread is running in the application.</short>
</element>

<!-- constant Visibility: default -->
<element name="StackError">
<short>Indicate whether there was a stack error.</short>
</element>

<!-- variable Visibility: default -->
<element name="ExitCode">
<short>Exit code for the program, will be communicated to the OS on exit.</short>
</element>

<!-- variable Visibility: default -->
<element name="RandSeed">
<short>Seed for <link id="Random"/> function.</short>
</element>

<!-- variable Visibility: default -->
<element name="IsLibrary">
<short><var>True</var> if the current module is a library. Otherwise module
is an excutable</short>
</element>

<!-- variable Visibility: default -->
<element name="IsConsole">
<short><var>True</var> for console applications, <var>False</var> for GUI applications.</short>
</element>

<!-- variable Visibility: default -->
<element name="fpc_threadvar_relocate_proc" skip="1">
</element>

<!-- variable Visibility: default -->
<element name="ThreadID">
<short>Current Thread ID.</short>
</element>

<!-- variable Visibility: default -->
<element name="Output">
<short>Standard output text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="Input">
<short>Standard input text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="StdOut">
<short>Alias for <link id="Output"/>.</short>
</element>

<!-- variable Visibility: default -->
<element name="StdErr">
<short>Standard diagnostic output text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="InOutRes">
<short>Result of last I/O operation. Read-Only.</short>
</element>

<!-- variable Visibility: default -->
<element name="StackBottom">
<short>Current stack bottom.</short>
</element>

<!-- variable Visibility: default -->
<element name="StackLength">
<short>Maximum stack length.</short>
</element>

<!-- function Visibility: default -->
<element name="IndexChar0">
<short>Return index of a character in null-terminated array of char.</short>
<descr> 
<var>IndexChar0</var> returns the index of the character <var>b</var> in the
null-terminated array <var>Buf</var>. At most <var>len</var> characters will
be searched, or the null character if it is encountered first. If the
character is not found, 0 is returned.
</descr>
<errors>
On error, 0 is returned.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexChar"/>
<link id="IndexWord"/>
<link id="IndexDWord"/>
<link id="CompareChar0"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="CompareChar0">
<short>Compare two buffers character by character till a null-character is reached.</short>
<descr>
<p>
<var>CompareChar0</var> compares 2 buffers <var>buf1</var> and <var>buf2</var>
for a maximum length of <var>len</var> or till a null character is reached
in either buffer. The result depends on the contents of the buffers:
</p>
<dl>
<dt>&lt; 0</dt><dd>If <var>buf1</var> contains a character less than the
corresponding character in <var>buf2</var>.</dd>
<dt>0</dt><dd>If both buffers are equal</dd>
<dt>&gt; 0</dt><dd>If <var>buf1</var> contains a character greater than the
corresponding character in <var>buf2</var>.</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareByte"/>
<link id="CompareChar"/>
<link id="CompareDWord"/>
<link id="CompareWord"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="prefetch">
<short>Prefetch a memory location</short>
<descr>
<var>Prefetch</var> can be used to optimize the CPU behaviour by already
loading a memory location. It is mainly used as a hint for those processors
that support it.
</descr>
<errors>
None.
</errors>
</element>

<!-- array type Visibility: default -->
<element name="real48">
<short>TP compatible real type (6 bytes) definition</short>
</element>

<!-- function Visibility: default -->
<element name="strpas">
<short>Convert a null-terminated string to a shortstring.</short>
<descr>
Converts a null terminated string in <var>P</var> to a Pascal string, and
returns
this string. The string is truncated at 255 characters.
</descr>
<errors>
None.
</errors>
</element>

<!-- function Visibility: default -->
<element name="strlen">
<short>Length of a null-terminated string.</short>
<descr>
Returns the length of the null-terminated string <var>P</var>.
</descr>
<errors>
None.
</errors>
</element>

<!-- function Visibility: default -->
<element name="Space">
<short>Return a string of spaces</short>
<descr>
<var>Space</var> returns a shortstring with length <var>B</var>, consisting
of spaces.
</descr>
<seealso>
<link id="StringOfChar"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="UniqueString">
<short>Make sure reference count of string is 1</short>
<descr>
<var>UniqueString</var> ensures that the ansistring <var>S</var> has
reference count 1. It makes a copy of <var>S</var> if this is necesary, and
returns the copy in <var>S</var>
</descr>
<errors>
None.
</errors>
</element>

<!-- procedure Visibility: default -->
<element name="SetTextLineEnding">
<short>Set the end-of-line character for the given text file.</short>
<descr>
<var>SetTextLineEnding</var> sets the end-of-line character for the text
file <var>F</var> to <var>Ending</var>. By default, this is the string
indicated by <link id="DefaultTextLineBreakStyle"/>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="DefaultTextLineBreakStyle"/>
<link id="TTextLineBreakStyle"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="get_frame">
<short>Return the current frame</short>
<descr>
<var>get_frame</var> returns a pointer to the current stack frame.
</descr>
<seealso>
<link id="get_caller_addr"/>
<link id="get_caller_frame"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="get_caller_addr">
<short>Return the address of the caller.</short>
<descr>
<var>get_caller_frame</var> returns a pointer to address ( the return
address)  of the caller  of the routine which has as frame <var>framebp</var>.
</descr>
<seealso>
<link id="get_frame"/>
<link id="get_caller_frame"/>
<link id="Dump_Stack"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="get_caller_frame">
<short>Return the frame pointer of the caller</short>
<descr>
<var>get_caller_frame</var> returns a pointer to the frame of the caller 
of the routine which has as frame <var>framebp</var>.
</descr>
<seealso>
<link id="get_caller_addr"/>
<link id="get_frame"/>
<link id="Dump_Stack"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="Dump_Stack">
<short>Dump stack to the given text file.</short>
<descr>
<var>Dump_Stack</var> prints a stack dump to the file <var>f</var>, with
base frame pointer <var>bp</var>
</descr>
<errors>
The file <var>f</var> must be opened for writing or an error will occur.
</errors>
<seealso>
<link id="get_caller_addr"/>
<link id="get_caller_frame"/>
<link id="get_frame"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="AddExitProc">
<short>Add an exit procedure to the exit procedure chain.</short>
<descr>
<var>AddExitProc</var> adds <var>Proc</var> to the exit procedure chain. At
program exit, all procedures added in this way will be called in reverse
order.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ExitProc"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SysInitExceptions">
<short>Initialize exceptions.</short>
<descr>
<var>SysInitExceptions</var> initializes the exception system. This
procedure should never be called directly, it is taken care of by the RTL.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="SysInitStdIO">
<short>Initialize standard input and output.</short>
<descr>
<var>SysInitStdIO</var> initializes the standard input and output files:
<link id="Output"/>, <link id="Input"/> and <link id="StdErr"/>. This
routine is called by the initialization code of the system unit, there
should be no need to call it directly.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="SysResetFPU">
<short>Reset the floating point unit.</short>
<descr>
<var>SysResetFPU</var> resets the floating point unit. There should normally
be no need to call this unit; the compiler itself takes care of this.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="AbstractError">
<short>Generate an abstract error.</short>
<descr>
<var>AbstractError</var> generates an abstract error (run-time error 211).
If the <link id="AbstractErrorProc"/> constant is set, it will be called
instead.
</descr>
<errors>
This routine causes a run-time error 211.
</errors>
<seealso>
<link id="AbstractErrorProc"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysBackTraceStr">
<short>Format an address suitable for inclusion in a backtrace</short>
<descr>
<var>SysBackTraceStr</var> will create a string representation of the 
address <var>Addr</var>, suitable for inclusion in a stack backtrace.
</descr>
<errors>
None.
</errors>
</element>

<!-- procedure Visibility: default -->
<element name="SysAssert">
<short>Standard Assert failure implementation</short>
<descr>
<var>SysAssert</var> is the standard implementation of the assertion failed
code. It is the default value of the <var>AssertErrorProc</var> constant.
It will print the assert message <var>Msg</var> together with the filename
<var>FName</var> and linenumber <var>LineNo</var> to standard error output
(<var>StdErr</var>) and will halt the program with exit code 227.
The error address <var>ErrorAddr</var> is ignored.
</descr>
<seealso>
<link id="AssertErrorProc"/>
</seealso>
</element>

<!-- function type Visibility: default -->
<element name="TBackTraceStrFunc">
<short>Type for formatting of backtrace dump.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TErrorProc">
<short>Standard error handler procedural type.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TAbstractErrorProc">
<short>Abstract error handler procedural type.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TAssertErrorProc">
<short>Assert error handler procedural type.</short>
</element>

<!-- constant Visibility: default -->
<element name="BackTraceStrFunc">
<short>Standard backtrace formatting routine</short>
<descr>
This handler is called to get a standard format for the backtrace routine.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ErrorProc">
<short>Custom error handling procedure.</short>
<descr>
<p>
If set, the <var>ErrorProc</var> constant is used when a run-time error
occurs. If it is not set, then the standard error handling is done: a stack
dump is performed, and the program exits with the indicated error code.
</p>
<p>
The <file>SysUtils</file> unit sets this procedure and raises an exception
in its handler.
</p>
</descr>
<seealso>
<link id="TErrorProc"/>
<link id="Halt"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AbstractErrorProc">
<short>Custom abstract error handling procedure</short>
<descr>
<p>
If set, the <var>AbstractErrorProc</var> constant is used when an abstract
error occurs. If it is not set, then the standard error handling is done:
A stack dump is performed, and the program exits with error code 211.
</p>
<p>
The <file>SysUtils</file> unit sets this procedure and raises an exception
in its handler.
</p>
</descr>
<seealso>
<link id="TAbstractErrorProc"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AssertErrorProc">
<short>Custom assert error handling procedure</short>
<descr>
<p>
If set, the <var>AbstractErrorProc</var> constant is used when an assert
error occurs. If it is not set, then the standard error handling is done:
The assertion error message is printed, together with the location of the
assertion, and A stack dump is performed, and the program exits with error code
227.
</p>
<p>
The <file>SysUtils</file> unit sets this procedure and raises an exception
in its handler.
</p>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="jmp_buf">
<short>Record type to store processor information.</short>
<seealso>
<link id="setjmp"/>
<link id="longjmp"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.ebx">
<short>EBX register.</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.esi">
<short>ESI register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.edi">
<short>EDI register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.bp">
<short>BP register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.sp">
<short>SP register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.pc">
<short>PC register</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PJmp_buf">
<short>Pointer to <link id="jmp_buf"/> record</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtInstanceSize">
<short>VMT Layout: Location of class instance size in VMT</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtParent">
<short>VMT Layout: location of pointer to parent VMT.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtClassName">
<short>VMT Layout: location of class name.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDynamicTable">
<short>VMT Layout: location of dynamic methods table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtMethodTable">
<short>VMT Layout: Method table start.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtFieldTable">
<short>VMT Layout: Location of fields table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtTypeInfo">
<short>VMT Layout: Location of class type information.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtInitTable">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtAutoTable">
<short>VMT layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtIntfTable">
<short>VMT layout: Interface table</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtMsgStrPtr">
<short>VMT layout: message strings table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtMethodStart">
<short>VMT layout: start of method table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDestroy">
<short>VMT Layout: Location of destructor pointer.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtNewInstance">
<short>VMT Layout: location of NewInstance method.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtFreeInstance">
<short>VMT Layout: location of FreeInstance method.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtSafeCallException">
<short>VMT  Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDefaultHandler">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtAfterConstruction">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtBeforeDestruction">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDefaultHandlerStr">
<short>VMT Layout: ?</short>
</element>

<!-- alias type Visibility: default -->
<element name="TextFile">
<short>Alias for <var>Text</var> file type.</short>
</element>

<!-- object Visibility: default -->
<element name="TObject">
<short>Parent class for all classes.</short>
<descr>
<var>TObject</var> is used as the parent class for all class definitions.
It contains some standard methods that are available in all classes.
</descr>
<seealso>
<link id="TClass"/>
</seealso>
</element>

<!-- "class of" type Visibility: default -->
<element name="TClass">
<short>Class of <link id="TObject"/>.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PClass">
<short>Pointer to <link id="TClass"/></short>
</element>

<!-- record type Visibility: default -->
<element name="TMsgStrTable">
<short>Record used in string message handler table.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMsgStrTable.name">
<short>Message name</short>
</element>

<!-- variable Visibility: default -->
<element name="TMsgStrTable.method">
<short>Method to call</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PMsgStrTable">
<short>Pointer to array of <link id="TMsgStrTable"/> records.</short>
</element>

<!-- record type Visibility: default -->
<element name="TStringMessageTable">
<short>String message table container for class.</short>
<descr>
Record used to describe the string messages handled by a class.
It consists of a count, followed by an array of <link id="TMsgStrTable"/>
records.
</descr>
<seealso>
<link id="TMsgStrTable"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TStringMessageTable.count">
<short>Number of messages in the string table.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TStringMessageTable.msgstrtable">
<short>First <link id="TMsgStrTable"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pstringmessagetable">
<short>Pointer to <link id="TStringMessageTable"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PGuid">
<short>Pointer to <link id="TGUID"/> type. </short>
</element>

<!-- record type Visibility: default -->
<element name="TGuid">
<short>Standard GUID representation type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pinterfaceentry">
<short>Pointer to <link id="tinterfaceentry"/> record.</short>
</element>

<!-- record type Visibility: default -->
<element name="tinterfaceentry">
<short>Interfaces table entry.</short>
<descr>
<var>tinterfaceentry</var> is used to store the list of Interfaces of a
class. This list is stored as an array of <var>tinterfaceentry</var>
records.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.IID">
<short>Unique GUID for this interface.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.VTable">
<short>Pointer to interface VTable.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.IOffset">
<short>Offset</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.IIDStr">
<short>Pointer to GUID string. Always assigned for COM.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pinterfacetable">
<short>Pointer to <link id="tinterfacetable"/> record.</short>
</element>

<!-- record type Visibility: default -->
<element name="tinterfacetable">
<short>Record to store list of interfaces of a class.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfacetable.EntryCount">
<short>Number of interfaces.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfacetable.Entries">
<short>Array of <link id="tinterfaceentry"/> records.</short>
</element>

<!-- object Visibility: default -->
<element name="TObject">
<short>Base class of all classes.</short>
<descr>
<var>TObject</var> is the parent root class for all classes in Object
Pascal. If a class has no parent class explicitly declared, it is dependent
on <var>TObject</var>. <var>TObject</var> introduces class methods that deal
with the class' type information, and contains all necessary methods to
create an instance at runtime, and to dispatch messages to the correct
method (both string and integer messages).
</descr>
<seealso>
<link id="TClass"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TObject.Create">
<short><var>TObject</var> Constructor</short>
<descr>
<var>Create</var> creates a new instance of <var>TObject</var>. Currently it
does nothing. It is also not virtual, so there is in principle no need to
call it directly. 
</descr>
<seealso>
<link id="TObject.Destroy">Destroy</link>
</seealso>
</element>

<!-- destructor Visibility: public -->
<element name="TObject.Destroy">
<short><var>TObject</var> destructor.</short>
<descr>
<p>
<var>Destroy</var> is the destructor of <var>TObject</var>. 
It will clean up the memory assigned to the instance. Descendent classes
should override destroy if they want to do additional clean-up. No other
destructor should be implemented.
</p>
<p>
It is bad programming practice to call <var>Destroy</var> directly. It is
better to call the <link id="TObject.Free">Free</link> method, because that
one will check first if <var>Self</var> is different from <var>Nil</var>.
</p>
<p>
To clean up an instance and reset the refence to the instance, it is best to
use the <link id="#rtl.sysutils.freeandnil">FreeAndNil</link> function.
</p>
</descr>
<seealso>
<link id="TObject.Create">Create</link>
<link id="TObject.Free">Free</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.newinstance">
<short>Allocate memory on the heap for a new instance</short>
<descr>
<var>NewInstance</var> allocates memory on the heap for a new instance of
the current class. If the memory was allocated, the class will be
initialized by a call to <link id="TObject.InitInstance">InitInstance</link>.
The function returns the newly initialized instance.
</descr>
<errors>
If not enough memory is available, a <var>Nil</var> pointer may be returned, 
or an exception may be raised.
</errors>
<seealso>
<link id="TObject.Create">Create</link>
<link id="TObject.InitInstance">InitInstance</link>
<link id="TObject.InstanceSize">InstanceSize</link>
<link id="TObject.FreeInstance">FreeInstance</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.FreeInstance">
<short>Clean up instance and free the memory reserved for the instance.</short>
<descr>
<var>FreeInstance</var> cleans up an instance of the current class, and
releases the heap memory occupied by the class instance.
</descr>
<seealso>
<link id="TObject.Destroy">Destroy</link>
<link id="TObject.InitInstance">InitInstance</link>
<link id="TObject.NewInstance">NewInstance</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.SafeCallException">
<short>Handle exception object</short>
<descr>
<var>SafeCallException</var> should be overridden to handle exceptions in a
method marked with the savecall directive. The implementation in
<var>TObject</var> simply returns zero.
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.DefaultHandler">
<short>Default handler for integer message handlers.</short>
<descr>
<var>DefaultHandler</var> is the default handler for messages. If a message
has an unknown message ID (i.e. does not appear in the table with integer
message handlers), then it will be passed to
<var>DefaultHandler</var> by the <link id="TObject.Dispatch">Dispatch</link>
method.
</descr>
<errors>
</errors>
<seealso>
<link id="TObject.Dispatch">Dispatch</link>
<link id="TObject.DefaultHandlerStr">DefaultHandlerStr</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.Free">
<short>Check for <var>Nil</var> and call destructor.</short>
<descr>
<var>Free</var> will check the <var>Self</var> pointer and calls
<link id="TObject.Destroy">Destroy</link> if it is different from
<var>Nil</var>. This is a safer method than calling <var>Destroy</var>
directly. If a reference to the object must be reset as well (a recommended
technque), then the function <link id="#rtl.sysutils.freeandnil">FreeAndNil</link> should be called.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.Destroy">Destroy</link>
<link id="#rtl.sysutils.freeandnil">FreeAndNil</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.InitInstance">
<short>Initialize a new class instance.</short>
<descr>
<var>InitInstance</var> initializes the memory pointer to by
<var>Instance</var>. This means that the VMT is initialized, and the
interface pointers are set up correctly.
The function returns the newly initialized instance.
</descr>
<seealso>
<link id="TObject.NewInstance">NewInstance</link>
<link id="TObject.Create">Create</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.CleanupInstance">
<short>Finalize the class instance.</short>
<descr>
<p>
<var>CleanUpinstance</var> finalizes the instance, i.e. takes care of all
reference counted objects, by decreasing their reference count by 1, and
freeing them if their count reaches zero.
</p>
<p>
Normally, <var>CleanupInstance</var> should never be called, it is called
automatically when the object is freed with it's constructor.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.Destroy">Destroy</link>
<link id="TObject.Free">Free</link>
<link id="TObject.InitInstance">InitInstance</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassInfo">
<short>Return a pointer to the type information for this class.</short>
<descr>
<var>ClassInfo</var> returns a pointer to the type information for this
class. This pointer can be used in the various type information routines.
</descr>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassType">
<short>Return a "class of" pointer for the current class</short>
<descr>
<var>ClassType</var> returns a <link id="TClass"/> class type reference for
the current class.
</descr>
<seealso>
<link id="TClass"/>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassName">ClassName</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassName">
<short>Return the current class name.</short>
<descr>
<var>ClassName</var> returns the class name for the current class, in
all-uppercase letters. To check for the class name, use the <link
id="TObject.ClassNameIs">ClassNameIs</link> class method.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TObject.ClassNameIs">ClassNameIs</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassNameIs">
<short>Check whether the class name equals the given name.</short>
<descr>
<var>ClassNameIs</var> checks whether <var>Name</var> equals the class name.
It takes of case sensitivity, i.e. it converts both names to uppercase
before comparing.
</descr>
<seealso>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TObject.ClassName">ClassName</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassParent">
<short>Return the parent class.</short>
<descr>
<var>ClassParent</var> returns the class of the parent class of the current
class. This is always different from <var>Nil</var>, except for
<var>TObject</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TObject.ClassName">ClassNameIs</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.InstanceSize">
<short>Return the size of an instance.</short>
<descr>
<var>InstanceSize</var> returns the number of bytes an instance takes in
memory. This is Just the memory occupied by the class structure, and does
not take into account any additional memory that might be allocated by the
constructor of the class.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.InitInstance">InitInstance</link>
<link id="TObject.ClassName">ClassName</link>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.InheritsFrom">
<short>Chck wether class is an ancestor.</short>
<descr>
<var>InheritsFrom</var> returns <var>True</var> if <var>AClass</var> is an
ancestor class from the current class, and returns false if it is not.
</descr>
<errors>
</errors>
<seealso>
<link id="TObject.ClassName">ClassName</link>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TClass"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.StringMessageTable">
<short>Return a pointer to the string message table.</short>
<descr>
<var>StringMessageTable</var> returns a pointer to the string message table,
which can be used to look up methods for dispatching a string message. It is
used by the <link id="TObject.DispatchStr">DispatchStr</link> method.
</descr>
<errors>
If there are no string message handlers, nil is returned.
</errors>
<seealso>
<link id="TObject.DispatchStr">DispatchStr</link>
<link id="TObject.Dispatch">Dispatch</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.Dispatch">
<short>Dispatch an integer message</short>
<descr>
<p>
<var>Dispatch</var> looks in the message handler table for a handler that
handles <var>message</var>. The message is identified by the first dword
(cardinal) in the message structure.
</p>
<p>
If no matching message handler is found, the message is passed to the
<link id="TObject.DefaultHandler">DefaultHandler</link> method, which can be
overridden by descendent classes to add custom handling of messages.
</p>
</descr>
<seealso>
<link id="TObject.DispatchStr">DispatchStr</link>
<link id="TObject.DefaultHandler">DefaultHandler</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.DispatchStr">
<short>Dispatch a string message.</short>
<descr>
<var>DispatchStr</var> extracts the message identifier from
<var>Message</var> and checks the message handler table to see if a handler
for the message is found, and calls the handler, passing along the message. 
If no handler is found, the default <link id="TObject.DefaultHandlerStr">DefaultHandlerStr</link> 
is called.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.DefaultHandlerStr">DefaultHandlerStr</link>
<link id="TObject.Dispatch">Dispatch</link>
<link id="TObject.DefaultHandler">DefaultHandler</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.MethodAddress">
<short>Return the address of a method</short>
<descr>
<var>MethodAddress</var> returns the address of a method, searching the
method by its name. The <var>Name</var> parameter specifies which method
should be taken. The search is conducted in a case-insensitive manner.
</descr>
<errors>
If no matching method is found, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="TObject.MethodName">MethodName</link>
<link id="TObject.FieldAddress">FieldAddress</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.MethodName">
<short>Return the name of a method.</short>
<descr>
<var>MethodName</var> searches the VMT for a method with the specified 
<var>address</var> and returns the name of the method.
</descr>
<errors>
If no method with the matching address is found, an empty string is
returned.
</errors>
<seealso>
<link id="TObject.MethodAddress">MethodAddress</link>
<link id="TObject.FieldAddress">FieldAddress</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.FieldAddress">
<short>Return the address of a field.</short>
<descr>
<var>FieldAddress</var> returns the address of the field with name <var>name</var>. 
The address is the address of the field in the current class instance.
</descr>
<errors>
If no field with the specified name is found, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="TObject.MethodAddress">MethodAddress</link>
<link id="TObject.MethodName">MethodName</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.AfterConstruction">
<short>Method called after the constructor was called.</short>
<descr>
<var>AfterConstruction</var> is a method called after the constructor was
called. It does nothing in the implementation of <var>TObject</var> and must
be overridden by descendent classes to provide specific behaviour that is
executed after the constructor has finished executing. (for instance, call
an event handler)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.BeforeDestruction">BeforeDestruction</link>
<link id="TObject.Create">Create</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.BeforeDestruction">
<short>Method called before the destructor is called.</short>
<descr>
<var>BeforeDestruction</var> is a method called before the destructor is
called. It does nothing in the implementation of <var>TObject</var> and must
be overridden by descendent classes to provide specific behaviour that is
executed before the destructor has finished executing. (for instance, call
an event handler)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.AfterConstruction">AfterConstruction</link>
<link id="TObject.Destroy">Destroy</link>
<link id="TObject.Free">Free</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.DefaultHandlerStr">
<short>Default handler for string messages.</short>
<descr>
<var>DefaultHandlerStr</var> is called for string messages which have no
handler associated with them in the string message handler table. The
implementation of <var>DefaultHandlerStr</var> in <var>TObject</var> does
nothing and mut be overridden by descendent classes to provide specific
message handling behaviour.
</descr>
<seealso>
<link id="TObject.DispatchStr">DispatchStr</link>
<link id="TObject.Dispatch">Dispatch</link>
<link id="TObject.DefaultHandler">DefaultHandler</link>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TExceptProc">
<short>Exception handler procedural type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PExceptObject">
<short>Pointer to Exception handler procedural type <link id="TExceptProc"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TExceptObject">
<short>Exception object</short>
<descr>
<var>TExceptObject</var> is the exception description record which is found
on the exception stack.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.FObject">
<short>Exception instance.</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Addr">
<short>Address where exception occurred</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Frame">
<short>Exception frame where exception occurred</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Next">
<short>Next exception object on the stack.</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.refcount">
<short>Reference count for this exception object</short>
</element>

<!-- constant Visibility: default -->
<element name="ExceptProc">
<short>Current exception handling procedure.</short>
<descr>
<p>
This constant points to the current exception handling procedure. 
This routine is called when an unhandled exception occurs, i.e. an exception
that is not stopped by a except block.
</p>
<p>
If the handler is not set, the RTL will emit a run-time error 217 when an
unhandler exception occurs.
</p>
<p>
It is set by the <link id="#rtl.sysutils">sysutils</link> unit. 
</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="RaiseProc">
<short>Procedure to raise an exception.</short>
</element>

<!-- function Visibility: default -->
<element name="RaiseList">
<short>List of currently raised exceptions.</short>
<descr>
<var>RaiseList</var> returns a pointer to the list of currently raised
exceptions (i.e. a pointer to the first exception block.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="AcquireExceptionObject">
<short>Obtain a reference to the current exception object</short>
<descr>
<p>
<var>AcquireExceptionObject</var> returns the current exception object.
It raises the reference count of the exception object, so it will not be
freed.  Calling this method is only valid within an except block.
</p>
<p>
The effect of this function is countered by re-raising an exception
via <var>raise;</var>
</p>
<p>
To make sure that the exception object is released when it is no longer
needed, <link id="ReleaseExceptionObject"/> must be called when the 
reference is no longer needed.
</p>
</descr>
<errors>
If there is no current exception, a run-time error 231 will occur.
</errors>
<seealso>
<link id="ReleaseExceptionObject"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="ReleaseExceptionObject">
<short>Decrease the reference count of the current exception object.</short>
<descr>
<p>
<var>ReleaseExceptionObject</var> decreases the reference count of the
current exception object. This should be called whenever a reference to the
exception object was obtained via the <link id="AcquireExceptionObject"/>
call.
</p>
<p>
Calling this method is only valid within an except block.
</p>
</descr>
<errors>
If there is no current exception object, a run-time error 231 will occur.
</errors>
<seealso>
<link id="AcquireExceptionObject"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="vtInteger">
<short>TVarRec type: Integer</short>
</element>

<!-- constant Visibility: default -->
<element name="vtBoolean">
<short>TVarRec type: Boolean</short>
</element>

<!-- constant Visibility: default -->
<element name="vtChar">
<short>TVarRec type: Char</short>
</element>

<!-- constant Visibility: default -->
<element name="vtExtended">
<short>TVarRec type: Extended</short>
</element>

<!-- constant Visibility: default -->
<element name="vtString">
<short>TVarRec type: String</short>
</element>

<!-- constant Visibility: default -->
<element name="vtPointer">
<short>TVarRec type: pointer</short>
</element>

<!-- constant Visibility: default -->
<element name="vtPChar">
<short>TVarRec type: PChar</short>
</element>

<!-- constant Visibility: default -->
<element name="vtObject">
<short>TVarRec type: Object instance</short>
</element>

<!-- constant Visibility: default -->
<element name="vtClass">
<short>TVarRec type: Class type</short>
</element>

<!-- constant Visibility: default -->
<element name="vtWideChar">
<short>TVarRec type: Widechar</short>
</element>

<!-- constant Visibility: default -->
<element name="vtPWideChar">
<short>TVarRec type: PWideChar</short>
</element>

<!-- constant Visibility: default -->
<element name="vtAnsiString">
<short>TVarRec type: Ansistring</short>
</element>

<!-- constant Visibility: default -->
<element name="vtCurrency">
<short>TVarRec type: Currency</short>
</element>

<!-- constant Visibility: default -->
<element name="vtVariant">
<short>TVarRec type: Variant</short>
</element>

<!-- constant Visibility: default -->
<element name="vtInterface">
<short>TVarRec type: Interface</short>
</element>

<!-- constant Visibility: default -->
<element name="vtWideString">
<short>TVarRec type: WideString</short>
</element>

<!-- constant Visibility: default -->
<element name="vtInt64">
<short>TVarRec type: Int64 (signed 64-bit integer)</short>
</element>

<!-- constant Visibility: default -->
<element name="vtQWord">
<short>TVarRec type: QWord (unsigned 64-bit integer)</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PVarRec">
<short>Pointer to <link id="TVarRec"/> type.</short>
</element>

<!-- record type Visibility: default -->
<element name="TVarRec">
<short>Record describing an element in an array of const</short>
<descr>
<var>TVarRec</var> is a record generated by the compiler for each element in
a <var>array of const</var> call. The procedure that receives the constant
array receives an array of <var>TVarRec</var> elements, with lower bound zero
and high bound equal to the number of elements in the array minus one
(as returned by <var>High(Args)</var>)
</descr>
<seealso>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="tdynarrayindex">
<short>Type with the correct size for index into a dynamic array.</short>
<descr>
A variable of type <var>tdynarrayindex</var> will always have the correct
size, suitable for serving as an index in a dynamic array.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="pdynarrayindex">
<short>Pointer to <link id="tdynarrayindex"/> type.</short>
</element>

<!-- array type Visibility: default -->
<element name="fpc_big_chararray" skip="1">
<short>Array of char.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="fpc_small_set" skip="1">
<short>Type with the size of a small set</short>
</element>

<!-- array type Visibility: default -->
<element name="fpc_normal_set" skip="1">
<short>Type with the size of a normal set</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PMemoryManager">
<short>Pointer to <link id="TMemoryManager"/> record</short>
</element>

<!-- record type Visibility: default -->
<element name="TMemoryManager">
<short>Record describing the current memory manager</short>
<descr>
<var>TMemoryManager</var> describes the memory manager. For more information
about the memory manager, see the programmer's reference. 
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.NeedLock">
<short>Does the memory manager require a lock</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.Getmem">
<short>Function called when memory must be allocated on the heap.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.Freemem">
<short>Function called when previously allocated memory can be freed again.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.FreememSize">
<short>Function called when previously allocated memory with a known size can be freed again.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.AllocMem">
<short>Same as getmem.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.ReAllocMem">
<short>Handler called when an allocated  memory block should be resized</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.MemSize">
<short>Return the size of a memory block.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.GetHeapStatus">
<short>Handler called when the heap status must be reported.</short>
</element>

<element name="GetHeapStatus">
<short>Return the memory manager heap status.</short>
</element>

<!-- record type Visibility: default -->
<element name="TMemoryMutexManager">
<short>Record describing the mutex manager for the heap.</short>
<descr>
When the heapmanager needs a lock, then the mutex manager is used to handle
the lock.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexInit">
<short>Initialize the mutex</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexDone">
<short>Finalize (i.e. dispose of) the mutex.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexLock">
<short>Lock the mutex</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexUnlock">
<short>Unlock the mutex.</short>
</element>

<!-- procedure Visibility: default -->
<element name="SetMemoryMutexManager">
<short>Procedure to set the mutex manager.</short>
<descr>
<var>SetMemoryMutexManager</var> sets the mutex manager used by the memory
manager to <var>MutexMgr</var>. The current mutex manager is returned in
<var>MutexMgr</var>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TMemoryMutexManager"/>
<link id="SetMemoryManager"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="growheapsizesmall">
<short>Fixed size small blocks grow rate</short>
</element>

<!-- constant Visibility: default -->
<element name="growheapsize1">
<short>Grow rate for block less than 256 Kb.</short>
</element>

<!-- constant Visibility: default -->
<element name="growheapsize2">
<short>Grow rate for block larger than 256 Kb.</short>
</element>

<!-- variable Visibility: default -->
<element name="ReturnNilIfGrowHeapFails">
<short>Describe behaviour if getmem fails.</short>
<descr>
<var>ReturnNilIfGrowHeapFails</var> describes what happens if there is no
more memory available from the operating system. if set to <var>True</var>
the memory manager will return <var>Nil</var>. If set to <var>False</var>
then a run-time error will occur.
</descr>
</element>

<!-- function Visibility: default -->
<element name="SysGetmem">
<short>System memory manager memory allocator.</short>
<descr>
<var>SysGetmem</var> is the system memory manager implementation for <link
id="GetMem"/> 
</descr>
<seealso>
<link id="GetMem"/>
<link id="GetMemory"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysFreemem">
<short>System memory manager free routine.</short>
<descr>
<var>SysFreeem</var> is the system memory manager implementation for <link id="FreeMem"/>
</descr>
<seealso>
<link id="FreeMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysFreememSize">
<short>System memory manager free routine.</short>
<descr>
<var>SysFreemSize</var> is the system memory manager implementation for <link
id="FreeMem"/>
</descr>
<seealso>
<link id="MemSize"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysMemSize">
<short>System memory manager: free size.</short>
<descr>
<var>SysFreemSize</var> is the system memory manager implementation for
<link id="MemSize"/>
</descr>
<seealso>
<link id="MemSize"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysAllocMem">
<short>System memory manager: Allocate memory</short>
<descr>
<var>SysFreemSize</var> is the system memory manager implementation for
<link id="AllocMem"/>
</descr>
<seealso>
<link id="AllocMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysTryResizeMem">
<short>System memory manager: attempt to resize memory.</short>
<descr>
<var>SysTryResizeMem</var> is a help routine for the system memory 
manager implementation for <link id="ReAllocMem"/>, <link
id="SysReAllocMem"/>
</descr>
<seealso>
<link id="SysReAllocMem"/>
<link id="ReAllocMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysReAllocMem">
<short>System memory manager: Reallocate memory</short>
<descr>
<var>SysReallocMem</var> is a help routine for the system memory
manager implementation for <link id="ReAllocMem"/>.
</descr>
<seealso>
<link id="ReAllocMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="Getmemory">
<short>Alias for <link id="GetMem"/></short>
<descr>
<var>Getmemory</var> is an alias for <link id="GetMem"/>.
</descr>
<seealso>
<link id="GetMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="Freememory">
<short>Alias for <link id="FreeMem"/></short>
<descr>
<var>FreeMemory</var> is an alias for <link id="FreeMem"/>.
</descr>
<seealso>
<link id="FreeMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="MemSize">
<short>Return the size of a memory block.</short>
<descr>
<var>MemSize</var> returns the size of a memory block on the heap.
</descr>
<errors>
Passing an invalid pointer may lead to run-time errors (access violations).
</errors>
<seealso>
<link id="GetMem"/>
<link id="FreeMem"/>
</seealso>
</element>

<element name="AllocMem">
<short>Alias for <link id="GetMem"/></short>
<descr>
<var>AllocMem</var> is an alias for <link id="GetMem"/>. 
</descr>
<seealso>
<link id="GetMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ReAllocMem">
<short>Re-allocate memory on the heap</short>
<descr>
<p>
<var>ReAllocMem</var> resizes the memory pointed to by <var>P</var> so it has size
<var>Size</var>. The value of <var>P</var> may change during this operation.
The contents of the memory pointed to by <var>P</var> (if any) will be copied to
the new location, but may be truncated if the newly allocated memory block
is smaller in size. If a larger block is allocated, only the used memory is
initialized, extra memory will not be zeroed out.
</p>
<p>
Note that <var>P</var> may be nil, in that case the behaviour of
<var>ReAllocMem</var> is equivalent to <var>Getmem</var>.
</p>
</descr>
<seealso>
<link id="GetMem"/>
<link id="FreeMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ReAllocMemory">
<short>Alias for <link id="ReAllocMem"/></short>
<descr>
<var>ReAllocMemory</var> is an alias for <link id="ReAllocMem"/>.
</descr>
<seealso>
<link id="ReAllocMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="AsmGetmem">
<short>Routine that can be called from assembler routines to get memory.</short>
<descr>
<var>AsmGetmem</var> is a routine that can be called from assembler code to
get memory. The assembler reader cannot decide which overloaded <link
id="GetMem"/> call should be used. <var>AsmGetMem</var> provides a unique
name that can be called from assembler. Other than that it is completely
equivalent to <var>GetMem</var>.
</descr>
<seealso>
<link id="GetMem"/>
<link id="AsmFreeMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="AsmFreemem">
<short>Routine that can be called from assembler routines to release memory.</short>
<descr>
<var>AsmFreemem</var> is a routine that can be called from assembler code to
release previously alocated memory. The assembler reader cannot decide which 
overloaded <link id="FreeMem"/> call should be used. <var>AsmFreeMem</var> 
provides a unique name that can be called from assembler. Other than that it 
is completely equivalent to <var>FreeMem</var>.
</descr>
<seealso>
<link id="FreeMem"/>
<link id="AsmGetMem"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="THandle">
<short>Type alias.</short>
<descr>
This type should be considered opaque. It is used to describe file and other
handles.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="LineEnding">
<short>Constant describing the current line ending character.</short>
<descr>
<p>
<var>LineEnding</var> is a constant which contains the current line-ending
character. This character is system dependent, and is initialized by the
system. It should not be set.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="sLineBreak"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LFNSupport">
<short>COnstant describing support for long filenames.</short>
<descr>
<p>
<var>LFNSupport</var> determines whether the current OS supports long file
names, i.e. filenames that are not of the form 8.3 as on ancient DOS
systems. If the value of this constant is <var>True</var> then long
filenames are supported. If it is false, then not.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</element>

<!-- constant Visibility: default -->
<element name="DirectorySeparator">
<short>Character used to separate directory parts.</short>
<descr>
<p>
<var>DirectorySeparator</var> is the character used by the current operating
system to separate directory parts in a pathname. This constant is system
dependent, and should not be set.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DriveSeparator">
<short>Character used to separate directory parts.</short>
<descr>
<p>
On systems that support driveletters, the <var>DriveSeparator</var> constant
denotes the character that separates the drive indicator from the directory
part in a filename path.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PathSeparator">
<short>Character used to separate paths in a search list</short>
<descr>
<p>
<var>PathSeparator</var> is the character used commonly on the current
operating system to separate paths in a list of paths, such as the 
<var>PATH</var> environment variable. 
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="DriveSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FileNameCaseSensitive">
<short>OS treatment of filenames is case sensitive.</short>
<descr>
<p>
<var>FileNameCaseSensitive</var> is <var>True</var> if case is important
when using filenames on the current OS. In this case, the OS will treat 
files with different cased names as different files. Note that this may 
depend on the filesystem: Unix operating systems that access a DOS or
Windows partition will have this constant set to true, but when writing to
the DOS partition, the casing is ignored.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="sLineBreak">
<short>Alias for <link id="LineEnding"/></short>
<descr>
<p>
<var>sLineBreak</var> is an alias for <link id="LineEnding"/> and is
supplied for Delphi compatibility.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DefaultTextLineBreakStyle">
<short>Default line ending style.</short>
<descr>
<p>
<var>DefaultTextLineBreakStyle</var> contains the default OS setting for the
<link id="TTextLineBreakStyle"/> type. It is initizliaed by the system unit,
and is used to determine the default line ending when writing to text files.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="SetTextLineEnding"/>
<link id="TTextLineBreakStyle"/>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="maxExitCode">
<short>Maximum exit code supported by the operating system.</short>
<descr>
<var>maxExitCode</var> is the maximum value for the <link id="Halt"/> call.
</descr>
<seealso>
<link id="Halt"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="UnusedHandle">
<short>Value indicating an unused file handle (as reported by the OS).</short>
</element>

<!-- constant Visibility: default -->
<element name="StdInputHandle">
<short>Value of the OS handle for the standard input file.</short>
</element>

<!-- constant Visibility: default -->
<element name="StdOutputHandle">
<short>Value of the OS handle for the standard output file.</short>
</element>

<!-- constant Visibility: default -->
<element name="StdErrorHandle">
<short>Value of the OS handle for the standard error-output file.</short>
</element>


<!-- variable Visibility: default -->
<element name="argc" skip="1">
<short>Number of command-line arguments.</short>
<descr>
<var>argc</var> contains the number of command-line arguments passed to
the program by the OS. It is not available on all systems.
</descr>
<seealso>
<link id="argv"/>
<link id="envp"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="argv">
<short>Pointer to the array of command-line arguments</short>
<descr>
<var>argv</var> contains a pointer to a <var>nil</var>-terminated 
array of null-terminated strings, containing the command-line 
arguments passed to the program by the OS. It is not available 
on all systems.
</descr>
<seealso>
<link id="argc"/>
<link id="envp"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="envp">
<short>Pointer to the array of environment variables</short>
<descr>
<var>envp</var> contains a pointer to a <var>nil</var>-terminated
array of null-terminated strings, containing the environment variables
passed to the program by the OS. It is not available on all systems.
</descr>
<seealso>
<link id="argc"/>
<link id="argv"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="SizeInt">
<short>Signed integer type which fits for sizes</short>
<seealso>
<link id="SizeUInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="SizeUInt">
<short>Unsigned Integer type which fits for sizes</short>
<seealso>
<link id="SizeInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="PtrInt">
<short>Signed integer type with same size as Pointer.</short>
<descr>
<var>PtrInt</var> is an integer type which has always the same size as a
pointer. When using integers which will be cast to pointers and vice versa,
use this type, never the regular integer type.
</descr>
<seealso>
<link id="PtrUInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="PtrUInt">
<short>Unsigned integer type with same size as Pointer.</short>
<descr>
<var>PtrUInt</var> is an unsigned integer type which has always the same size as a
pointer. When using integers which will be cast to pointers and vice versa,
use this type, never the regular Cardinal type.
</descr>
<seealso>
<link id="PtrInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="ValSInt">
<short>Val-Signed integer.</short>
<descr>
Integer with teh same size as the return code of the <link id="Val"/>
function.
</descr>
<seealso>
<link id="Val"/>
<link id="ValUInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="ValUInt">
<short>Val-unsigned integer</short>
<descr>
Integer with teh same size as the return code of the <link id="Val"/>
function.
</descr>
<seealso>
<link id="Val"/>
<link id="ValUInt"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PVariant">
<short>Pointer to <var>Variant</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="POleVariant">
<short>Pointer to <var>OleVariant</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PWideChar">
<short>Pointer to <link id="WChar"/>.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPWideChar">
<short>Pointer to link id="PWideChar"> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="UCS2Char">
<short>UCS2 unicode character.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PUCS2Char">
<short>Pointer to <link id="UCS2Char"/> character.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PText">
<short>Pointer to text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="ErrOutput">
<short>Alias for <link id="StdErr"/></short>
<descr>
<var>ErrOutput</var> is provided for Delphi compatibility.
</descr>
<seealso>
<link id="StdErr"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_lo_word">
<short>FPC compiler internal procedure index: lo (word)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_hi_word">
<short>FPC compiler internal procedure index: hi (word)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_lo_long">
<short>FPC compiler internal procedure index: lo (long)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_hi_long">
<short>FPC compiler internal procedure index: hi (long)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_ord_x">
<short>FPC compiler internal procedure index: ord </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_length_string">
<short>FPC compiler internal procedure index: length</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_chr_byte">
<short>FPC compiler internal procedure index: chr</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_write_x">
<short>FPC compiler internal procedure index: write</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_writeln_x">
<short>FPC compiler internal procedure index: writeln</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_read_x">
<short>FPC compiler internal procedure index: read</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_readln_x">
<short>FPC compiler internal procedure index: readln</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_concat_x">
<short>FPC compiler internal procedure index: concat </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_assigned_x">
<short>FPC compiler internal procedure index: assigned </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_str_x_string">
<short>FPC compiler internal procedure index: str </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_ofs_x">
<short>FPC compiler internal procedure index: ofs </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sizeof_x">
<short>FPC compiler internal procedure index: sizeof </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_typeof_x">
<short>FPC compiler internal procedure index: typeof </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_val_x">
<short>FPC compiler internal procedure index: val </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_reset_x">
<short>FPC compiler internal procedure index: reset </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_rewrite_x">
<short>FPC compiler internal procedure index: rewrite </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_low_x">
<short>FPC compiler internal procedure index: low </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_high_x">
<short>FPC compiler internal procedure index: high </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_seg_x">
<short>FPC compiler internal procedure index: seg </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_pred_x">
<short>FPC compiler internal procedure index: pred </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_succ_x">
<short>FPC compiler internal procedure index: succ </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_reset_typedfile">
<short>FPC compiler internal procedure index: reset </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_rewrite_typedfile">
<short>FPC compiler internal procedure index: rewrite </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_settextbuf_file_x">
<short>FPC compiler internal procedure index: settextbuf </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_inc_x">
<short>FPC compiler internal procedure index: inc </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_dec_x">
<short>FPC compiler internal procedure index: dec </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_include_x_y">
<short>FPC compiler internal procedure index:  include </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_exclude_x_y">
<short>FPC compiler internal procedure index: exclude </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_break">
<short>FPC compiler internal procedure index: break </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_continue">
<short>FPC compiler internal procedure index: continue </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_assert_x_y">
<short>FPC compiler internal procedure index: assert </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_addr_x">
<short>FPC compiler internal procedure index: addr </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_typeinfo_x">
<short>FPC compiler internal procedure index: typeinfo </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_setlength_x">
<short>FPC compiler internal procedure index: setlength </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_finalize_x">
<short>FPC compiler internal procedure index: finalize </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_new_x">
<short>FPC compiler internal procedure index: new </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_dispose_x">
<short>FPC compiler internal procedure index: dispose  </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_exit">
<short>FPC compiler internal procedure index: exit </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_copy_x">
<short>FPC compiler internal procedure index: copy  </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_initialize_x">
<short>FPC compiler internal procedure index: initialize </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_leave">
<short>FPC compiler internal procedure index: leave </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_cycle">
<short>FPC compiler internal procedure index: cycle </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_trunc">
<short>FPC compiler internal procedure index: trunc </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_round">
<short>FPC compiler internal procedure index: round </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_frac">
<short>FPC compiler internal procedure index: frac </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_abs">
<short>FPC compiler internal procedure index: abs </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_int">
<short>FPC compiler internal procedure index: int </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_sqr">
<short>FPC compiler internal procedure index: sqr </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_odd">
<short>FPC compiler internal procedure index: sqr </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_ptr">
<short>FPC compiler internal procedure index: sqr </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_swap_word">
<short>FPC compiler internal procedure index: swap (word) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_swap_long">
<short>FPC compiler internal procedure index: swap (long) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_pi">
<short>FPC compiler internal procedure index: pi </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_sqrt">
<short>FPC compiler internal procedure index: sqrt </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_arctan">
<short>FPC compiler internal procedure index: arctan </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_cos">
<short>FPC compiler internal procedure index: cos </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_exp">
<short>FPC compiler internal procedure index: exp </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_ln">
<short>FPC compiler internal procedure index: in </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_sin">
<short>FPC compiler internal procedure index: sin </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_lo_qword">
<short>FPC compiler internal procedure index: lo (qword)  </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_hi_qword">
<short>FPC compiler internal procedure index: hi (qword) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_cos_real">
<short>FPC compiler internal procedure index: cos (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_pi">
<short>FPC compiler internal procedure index: pi </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_abs_real">
<short>FPC compiler internal procedure index: abs (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sqr_real">
<short>FPC compiler internal procedure index: sqr (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sqrt_real">
<short>FPC compiler internal procedure index: sqrt (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_arctan_real">
<short>FPC compiler internal procedure index: arctan (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_ln_real">
<short>FPC compiler internal procedure index: ln (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sin_real">
<short>FPC compiler internal procedure index: sin (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_swap_qword">
<short>FPC compiler internal procedure index: swap (qword) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_prefetch_var">
<short>FPC compiler internal procedure index: prefetch  </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpeqb">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpeqw">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpeqd">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpgtb">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpgtw">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpgtd">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<element name="fpc_abs_real">
<short>FPC internal compiler routine: abs_real</short>
</element>


<element name="fpc_AbstractErrorIntern">
<short>FPC internal compiler routine: AbstractErrorIntern</short>
</element>


<element name="fpc_Addref">
<short>FPC internal compiler routine: Addref</short>
</element>


<element name="fpc_ansistr_append_ansistring">
<short>FPC internal compiler routine: ansistr_append_ansistring</short>
</element>


<element name="fpc_ansistr_append_char">
<short>FPC internal compiler routine: ansistr_append_char</short>
</element>


<element name="fpc_ansistr_append_shortstring">
<short>FPC internal compiler routine: ansistr_append_shortstring</short>
</element>


<element name="fpc_AnsiStr_Assign">
<short>FPC internal compiler routine: AnsiStr_Assign</short>
</element>


<element name="fpc_AnsiStr_CheckRange">
<short>FPC internal compiler routine: AnsiStr_CheckRange</short>
</element>


<element name="fpc_AnsiStr_CheckZero">
<short>FPC internal compiler routine: AnsiStr_CheckZero</short>
</element>


<element name="fpc_AnsiStr_Compare">
<short>FPC internal compiler routine: AnsiStr_Compare</short>
</element>


<element name="fpc_AnsiStr_Concat">
<short>FPC internal compiler routine: AnsiStr_Concat</short>
</element>


<element name="fpc_AnsiStr_Concat_multi">
<short>FPC internal compiler routine: AnsiStr_Concat_multi</short>
</element>


<element name="fpc_ansistr_Copy">
<short>FPC internal compiler routine: ansistr_Copy</short>
</element>


<element name="fpc_ansistr_decr_ref">
<short>FPC internal compiler routine: ansistr_decr_ref</short>
</element>


<element name="fpc_AnsiStr_Float">
<short>FPC internal compiler routine: AnsiStr_Float</short>
</element>


<element name="fpc_ansistr_incr_ref">
<short>FPC internal compiler routine: ansistr_incr_ref</short>
</element>


<element name="fpc_ansistr_int64">
<short>FPC internal compiler routine: ansistr_int64</short>
</element>


<element name="fpc_ansistr_qword">
<short>FPC internal compiler routine: ansistr_qword</short>
</element>


<element name="fpc_AnsiStr_SetLength">
<short>FPC internal compiler routine: AnsiStr_SetLength</short>
</element>


<element name="fpc_AnsiStr_sint">
<short>FPC internal compiler routine: AnsiStr_sint</short>
</element>


<element name="fpc_ansistr_to_chararray">
<short>FPC internal compiler routine: ansistr_to_chararray</short>
</element>


<element name="fpc_AnsiStr_To_ShortStr">
<short>FPC internal compiler routine: AnsiStr_To_ShortStr</short>
</element>


<element name="fpc_ansistr_to_widechararray">
<short>FPC internal compiler routine: ansistr_to_widechararray</short>
</element>


<element name="fpc_AnsiStr_To_WideStr">
<short>FPC internal compiler routine: AnsiStr_To_WideStr</short>
</element>


<element name="fpc_AnsiStr_uint">
<short>FPC internal compiler routine: AnsiStr_uint</short>
</element>


<element name="fpc_ansistr_Unique">
<short>FPC internal compiler routine: ansistr_Unique</short>
</element>


<element name="fpc_arctan_real">
<short>FPC internal compiler routine: arctan_real</short>
</element>


<element name="fpc_assert">
<short>FPC internal compiler routine: assert</short>
</element>


<element name="fpc_Catches">
<short>FPC internal compiler routine: Catches</short>
</element>


<element name="fpc_chararray_Float">
<short>FPC internal compiler routine: chararray_Float</short>
</element>


<element name="fpc_chararray_int64">
<short>FPC internal compiler routine: chararray_int64</short>
</element>


<element name="fpc_chararray_qword">
<short>FPC internal compiler routine: chararray_qword</short>
</element>


<element name="fpc_chararray_sint">
<short>FPC internal compiler routine: chararray_sint</short>
</element>


<element name="fpc_CharArray_To_AnsiStr">
<short>FPC internal compiler routine: CharArray_To_AnsiStr</short>
</element>


<element name="fpc_chararray_to_shortstr">
<short>FPC internal compiler routine: chararray_to_shortstr</short>
</element>


<element name="fpc_CharArray_To_WideStr">
<short>FPC internal compiler routine: CharArray_To_WideStr</short>
</element>


<element name="fpc_chararray_uint">
<short>FPC internal compiler routine: chararray_uint</short>
</element>


<element name="fpc_char_copy">
<short>FPC internal compiler routine: char_copy</short>
</element>


<element name="fpc_Char_To_AnsiStr">
<short>FPC internal compiler routine: Char_To_AnsiStr</short>
</element>


<element name="fpc_Char_To_WideStr">
<short>FPC internal compiler routine: Char_To_WideStr</short>
</element>


<element name="fpc_class_as_intf">
<short>FPC internal compiler routine: class_as_intf</short>
</element>


<element name="fpc_cos_real">
<short>FPC internal compiler routine: cos_real</short>
</element>


<element name="fpc_DecRef">
<short>FPC internal compiler routine: DecRef</short>
</element>


<element name="fpc_divbyzero">
<short>FPC internal compiler routine: divbyzero</short>
</element>


<element name="fpc_div_int64">
<short>FPC internal compiler routine: div_int64</short>
</element>


<element name="fpc_div_qword">
<short>FPC internal compiler routine: div_qword</short>
</element>


<element name="fpc_do_as">
<short>FPC internal compiler routine: do_as</short>
</element>


<element name="fpc_do_is">
<short>FPC internal compiler routine: do_is</short>
</element>


<element name="fpc_dynarray_clear">
<short>FPC internal compiler routine: dynarray_clear</short>
</element>


<element name="fpc_dynarray_copy">
<short>FPC internal compiler routine: dynarray_copy</short>
</element>


<element name="fpc_dynarray_decr_ref">
<short>FPC internal compiler routine: dynarray_decr_ref</short>
</element>


<element name="fpc_dynarray_high">
<short>FPC internal compiler routine: dynarray_high</short>
</element>


<element name="fpc_dynarray_incr_ref">
<short>FPC internal compiler routine: dynarray_incr_ref</short>
</element>


<element name="fpc_dynarray_length">
<short>FPC internal compiler routine: dynarray_length</short>
</element>


<element name="fpc_dynarray_setlength">
<short>FPC internal compiler routine: dynarray_setlength</short>
</element>


<element name="fpc_dynarray_to_variant">
<short>FPC internal compiler routine: dynarray_to_variant</short>
</element>


<element name="fpc_exp_real">
<short>FPC internal compiler routine: exp_real</short>
</element>


<element name="fpc_finalize">
<short>FPC internal compiler routine: finalize</short>
</element>


<element name="fpc_finalize_array">
<short>FPC internal compiler routine: finalize_array</short>
</element>


<element name="fpc_frac_real">
<short>FPC internal compiler routine: frac_real</short>
</element>


<element name="fpc_freemem">
<short>FPC internal compiler routine: freemem</short>
</element>


<element name="fpc_get_input">
<short>FPC internal compiler routine: get_input</short>
</element>


<element name="fpc_getmem">
<short>FPC internal compiler routine: getmem</short>
</element>


<element name="fpc_get_output">
<short>FPC internal compiler routine: get_output</short>
</element>


<element name="fpc_help_constructor">
<short>FPC internal compiler routine: help_constructor</short>
</element>


<element name="fpc_help_destructor">
<short>FPC internal compiler routine: help_destructor</short>
</element>


<element name="fpc_help_fail">
<short>FPC internal compiler routine: help_fail</short>
</element>


<element name="fpc_in_exp_real">
<short>FPC internal compiler routine: in_exp_real</short>
</element>


<element name="fpc_in_fillchar_x">
<short>FPC internal compiler routine: in_fillchar_x</short>
</element>


<element name="fpc_in_frac_real">
<short>FPC internal compiler routine: in_frac_real</short>
</element>


<element name="fpc_in_get_caller_addr">
<short>FPC internal compiler routine: in_get_caller_addr</short>
</element>


<element name="fpc_in_get_caller_frame">
<short>FPC internal compiler routine: in_get_caller_frame</short>
</element>


<element name="fpc_in_get_frame">
<short>FPC internal compiler routine: in_get_frame</short>
</element>


<element name="fpc_in_int_real">
<short>FPC internal compiler routine: in_int_real</short>
</element>


<element name="fpc_Initialize">
<short>FPC internal compiler routine: Initialize</short>
</element>


<element name="fpc_InitializeUnits">
<short>FPC internal compiler routine: InitializeUnits</short>
</element>


<element name="fpc_in_move_x">
<short>FPC internal compiler routine: in_move_x</short>
</element>


<element name="fpc_in_pi_real">
<short>FPC internal compiler routine: in_pi_real</short>
</element>


<element name="fpc_in_round_real">
<short>FPC internal compiler routine: in_round_real</short>
</element>


<element name="fpc_in_slice">
<short>FPC internal compiler routine: in_slice</short>
</element>


<element name="fpc_interface_to_variant">
<short>FPC internal compiler routine: interface_to_variant</short>
</element>


<element name="fpc_intf_as">
<short>FPC internal compiler routine: intf_as</short>
</element>


<element name="fpc_intf_assign">
<short>FPC internal compiler routine: intf_assign</short>
</element>


<element name="fpc_intf_decr_ref">
<short>FPC internal compiler routine: intf_decr_ref</short>
</element>


<element name="fpc_intf_incr_ref">
<short>FPC internal compiler routine: intf_incr_ref</short>
</element>


<element name="fpc_int_real">
<short>FPC internal compiler routine: int_real</short>
</element>


<element name="fpc_in_trunc_real">
<short>FPC internal compiler routine: in_trunc_real</short>
</element>


<element name="fpc_iocheck">
<short>FPC internal compiler routine: iocheck</short>
</element>


<element name="fpc_ln_real">
<short>FPC internal compiler routine: ln_real</short>
</element>


<element name="fpc_mod_int64">
<short>FPC internal compiler routine: mod_int64</short>
</element>


<element name="fpc_mod_qword">
<short>FPC internal compiler routine: mod_qword</short>
</element>


<element name="fpc_mul_int64">
<short>FPC internal compiler routine: mul_int64</short>
</element>


<element name="fpc_mul_qword">
<short>FPC internal compiler routine: mul_qword</short>
</element>


<element name="fpc_overflow">
<short>FPC internal compiler routine: overflow</short>
</element>


<element name="fpc_pchar_length">
<short>FPC internal compiler routine: pchar_length</short>
</element>


<element name="fpc_PChar_To_AnsiStr">
<short>FPC internal compiler routine: PChar_To_AnsiStr</short>
</element>


<element name="fpc_pchar_to_shortstr">
<short>FPC internal compiler routine: pchar_to_shortstr</short>
</element>


<element name="fpc_PChar_To_WideStr">
<short>FPC internal compiler routine: PChar_To_WideStr</short>
</element>


<element name="fpc_pi_real">
<short>FPC internal compiler routine: pi_real</short>
</element>


<element name="fpc_PopAddrStack">
<short>FPC internal compiler routine: PopAddrStack</short>
</element>


<element name="fpc_PopObjectStack">
<short>FPC internal compiler routine: PopObjectStack</short>
</element>


<element name="fpc_PopSecondObjectStack">
<short>FPC internal compiler routine: PopSecondObjectStack</short>
</element>


<element name="fpc_PushExceptAddr">
<short>FPC internal compiler routine: PushExceptAddr</short>
</element>


<element name="fpc_PushExceptObj">
<short>FPC internal compiler routine: PushExceptObj</short>
</element>


<element name="fpc_pwidechar_length">
<short>FPC internal compiler routine: pwidechar_length</short>
</element>


<element name="fpc_PWideChar_To_AnsiStr">
<short>FPC internal compiler routine: PWideChar_To_AnsiStr</short>
</element>


<element name="fpc_PWideChar_To_ShortStr">
<short>FPC internal compiler routine: PWideChar_To_ShortStr</short>
</element>


<element name="fpc_PWideChar_To_WideStr">
<short>FPC internal compiler routine: PWideChar_To_WideStr</short>
</element>


<element name="fpc_Raiseexception">
<short>FPC internal compiler routine: Raiseexception</short>
</element>


<element name="fpc_rangeerror">
<short>FPC internal compiler routine: rangeerror</short>
</element>


<element name="fpc_Read_End">
<short>FPC internal compiler routine: Read_End</short>
</element>


<element name="fpc_ReadLn_End">
<short>FPC internal compiler routine: ReadLn_End</short>
</element>


<element name="fpc_Read_Text_AnsiStr">
<short>FPC internal compiler routine: Read_Text_AnsiStr</short>
</element>


<element name="fpc_Read_Text_Char">
<short>FPC internal compiler routine: Read_Text_Char</short>
</element>


<element name="fpc_Read_Text_Float">
<short>FPC internal compiler routine: Read_Text_Float</short>
</element>


<element name="fpc_Read_Text_Int64">
<short>FPC internal compiler routine: Read_Text_Int64</short>
</element>


<element name="fpc_Read_Text_PChar_As_Array">
<short>FPC internal compiler routine: Read_Text_PChar_As_Array</short>
</element>


<element name="fpc_Read_Text_PChar_As_Pointer">
<short>FPC internal compiler routine: Read_Text_PChar_As_Pointer</short>
</element>


<element name="fpc_Read_Text_QWord">
<short>FPC internal compiler routine: Read_Text_QWord</short>
</element>


<element name="fpc_Read_Text_ShortStr">
<short>FPC internal compiler routine: Read_Text_ShortStr</short>
</element>


<element name="fpc_Read_Text_SInt">
<short>FPC internal compiler routine: Read_Text_SInt</short>
</element>


<element name="fpc_Read_Text_UInt">
<short>FPC internal compiler routine: Read_Text_UInt</short>
</element>


<element name="fpc_ReRaise">
<short>FPC internal compiler routine: ReRaise</short>
</element>


<element name="fpc_reset_typed">
<short>FPC internal compiler routine: reset_typed</short>
</element>


<element name="fpc_rewrite_typed">
<short>FPC internal compiler routine: rewrite_typed</short>
</element>


<element name="fpc_round_real">
<short>FPC internal compiler routine: round_real</short>
</element>


<element name="fpc_set_add_sets">
<short>FPC internal compiler routine: set_add_sets</short>
</element>


<element name="fpc_set_comp_sets">
<short>FPC internal compiler routine: set_comp_sets</short>
</element>


<element name="fpc_set_contains_sets">
<short>FPC internal compiler routine: set_contains_sets</short>
</element>


<element name="fpc_set_create_element">
<short>FPC internal compiler routine: set_create_element</short>
</element>


<element name="fpc_set_in_byte">
<short>FPC internal compiler routine: set_in_byte</short>
</element>


<element name="fpc_set_load_small">
<short>FPC internal compiler routine: set_load_small</short>
</element>


<element name="fpc_set_mul_sets">
<short>FPC internal compiler routine: set_mul_sets</short>
</element>


<element name="fpc_set_set_byte">
<short>FPC internal compiler routine: set_set_byte</short>
</element>


<element name="fpc_set_set_range">
<short>FPC internal compiler routine: set_set_range</short>
</element>


<element name="fpc_set_sub_sets">
<short>FPC internal compiler routine: set_sub_sets</short>
</element>


<element name="fpc_set_symdif_sets">
<short>FPC internal compiler routine: set_symdif_sets</short>
</element>


<element name="fpc_set_unset_byte">
<short>FPC internal compiler routine: set_unset_byte</short>
</element>


<element name="fpc_shortstr_append_shortstr">
<short>FPC internal compiler routine: shortstr_append_shortstr</short>
</element>


<element name="fpc_shortstr_compare">
<short>FPC internal compiler routine: shortstr_compare</short>
</element>


<element name="fpc_shortstr_concat">
<short>FPC internal compiler routine: shortstr_concat</short>
</element>


<element name="fpc_shortstr_Copy">
<short>FPC internal compiler routine: shortstr_Copy</short>
</element>


<element name="fpc_ShortStr_Float">
<short>FPC internal compiler routine: ShortStr_Float</short>
</element>


<element name="fpc_shortstr_int64">
<short>FPC internal compiler routine: shortstr_int64</short>
</element>


<element name="fpc_shortstr_qword">
<short>FPC internal compiler routine: shortstr_qword</short>
</element>


<element name="fpc_Shortstr_SetLength">
<short>FPC internal compiler routine: Shortstr_SetLength</short>
</element>


<element name="fpc_ShortStr_sint">
<short>FPC internal compiler routine: ShortStr_sint</short>
</element>


<element name="fpc_ShortStr_To_AnsiStr">
<short>FPC internal compiler routine: ShortStr_To_AnsiStr</short>
</element>


<element name="fpc_shortstr_to_chararray">
<short>FPC internal compiler routine: shortstr_to_chararray</short>
</element>


<element name="fpc_shortstr_to_shortstr">
<short>FPC internal compiler routine: shortstr_to_shortstr</short>
</element>


<element name="fpc_shortstr_to_widechararray">
<short>FPC internal compiler routine: shortstr_to_widechararray</short>
</element>


<element name="fpc_ShortStr_To_WideStr">
<short>FPC internal compiler routine: ShortStr_To_WideStr</short>
</element>


<element name="fpc_shortstr_uint">
<short>FPC internal compiler routine: shortstr_uint</short>
</element>


<element name="fpc_sin_real">
<short>FPC internal compiler routine: sin_real</short>
</element>


<element name="fpc_sqr_real">
<short>FPC internal compiler routine: sqr_real</short>
</element>


<element name="fpc_sqrt_real">
<short>FPC internal compiler routine: sqrt_real</short>
</element>


<element name="fpc_trunc_real">
<short>FPC internal compiler routine: trunc_real</short>
</element>


<element name="fpc_typed_read">
<short>FPC internal compiler routine: typed_read</short>
</element>


<element name="fpc_typed_write">
<short>FPC internal compiler routine: typed_write</short>
</element>


<element name="fpc_Val_int64_AnsiStr">
<short>FPC internal compiler routine: Val_int64_AnsiStr</short>
</element>


<element name="fpc_val_int64_shortstr">
<short>FPC internal compiler routine: val_int64_shortstr</short>
</element>


<element name="fpc_Val_int64_WideStr">
<short>FPC internal compiler routine: Val_int64_WideStr</short>
</element>


<element name="fpc_Val_qword_AnsiStr">
<short>FPC internal compiler routine: Val_qword_AnsiStr</short>
</element>


<element name="fpc_val_qword_shortstr">
<short>FPC internal compiler routine: val_qword_shortstr</short>
</element>


<element name="fpc_Val_qword_WideStr">
<short>FPC internal compiler routine: Val_qword_WideStr</short>
</element>


<element name="fpc_Val_Real_AnsiStr">
<short>FPC internal compiler routine: Val_Real_AnsiStr</short>
</element>


<element name="fpc_Val_Real_ShortStr">
<short>FPC internal compiler routine: Val_Real_ShortStr</short>
</element>


<element name="fpc_Val_Real_WideStr">
<short>FPC internal compiler routine: Val_Real_WideStr</short>
</element>


<element name="fpc_Val_SInt_AnsiStr">
<short>FPC internal compiler routine: Val_SInt_AnsiStr</short>
</element>


<element name="fpc_Val_SInt_ShortStr">
<short>FPC internal compiler routine: Val_SInt_ShortStr</short>
</element>


<element name="fpc_Val_SInt_WideStr">
<short>FPC internal compiler routine: Val_SInt_WideStr</short>
</element>


<element name="fpc_Val_UInt_AnsiStr">
<short>FPC internal compiler routine: Val_UInt_AnsiStr</short>
</element>


<element name="fpc_Val_UInt_Shortstr">
<short>FPC internal compiler routine: Val_UInt_Shortstr</short>
</element>


<element name="fpc_Val_UInt_WideStr">
<short>FPC internal compiler routine: Val_UInt_WideStr</short>
</element>


<element name="fpc_vararray_get">
<short>FPC internal compiler routine: vararray_get</short>
</element>


<element name="fpc_vararray_put">
<short>FPC internal compiler routine: vararray_put</short>
</element>


<element name="fpc_variant_copy">
<short>FPC internal compiler routine: variant_copy</short>
</element>


<element name="fpc_variant_to_dynarray">
<short>FPC internal compiler routine: variant_to_dynarray</short>
</element>


<element name="fpc_variant_to_interface">
<short>FPC internal compiler routine: variant_to_interface</short>
</element>


<element name="fpc_WideCharArray_To_AnsiStr">
<short>FPC internal compiler routine: WideCharArray_To_AnsiStr</short>
</element>


<element name="fpc_WideCharArray_To_ShortStr">
<short>FPC internal compiler routine: WideCharArray_To_ShortStr</short>
</element>


<element name="fpc_WideCharArray_To_WideStr">
<short>FPC internal compiler routine: WideCharArray_To_WideStr</short>
</element>


<element name="fpc_WideStr_Assign">
<short>FPC internal compiler routine: WideStr_Assign</short>
</element>


<element name="fpc_WideStr_CheckRange">
<short>FPC internal compiler routine: WideStr_CheckRange</short>
</element>


<element name="fpc_WideStr_CheckZero">
<short>FPC internal compiler routine: WideStr_CheckZero</short>
</element>


<element name="fpc_WideStr_Compare">
<short>FPC internal compiler routine: WideStr_Compare</short>
</element>


<element name="fpc_WideStr_Concat">
<short>FPC internal compiler routine: WideStr_Concat</short>
</element>


<element name="fpc_WideStr_Concat_multi">
<short>FPC internal compiler routine: WideStr_Concat_multi</short>
</element>


<element name="fpc_widestr_Copy">
<short>FPC internal compiler routine: widestr_Copy</short>
</element>


<element name="fpc_WideStr_Decr_Ref">
<short>FPC internal compiler routine: WideStr_Decr_Ref</short>
</element>


<element name="fpc_WideStr_Float">
<short>FPC internal compiler routine: WideStr_Float</short>
</element>


<element name="fpc_WideStr_Incr_Ref">
<short>FPC internal compiler routine: WideStr_Incr_Ref</short>
</element>


<element name="fpc_widestr_int64">
<short>FPC internal compiler routine: widestr_int64</short>
</element>


<element name="fpc_widestr_qword">
<short>FPC internal compiler routine: widestr_qword</short>
</element>


<element name="fpc_WideStr_SetLength">
<short>FPC internal compiler routine: WideStr_SetLength</short>
</element>


<element name="fpc_WideStr_sint">
<short>FPC internal compiler routine: WideStr_sint</short>
</element>


<element name="fpc_WideStr_To_AnsiStr">
<short>FPC internal compiler routine: WideStr_To_AnsiStr</short>
</element>


<element name="fpc_widestr_to_chararray">
<short>FPC internal compiler routine: widestr_to_chararray</short>
</element>


<element name="fpc_WideStr_To_ShortStr">
<short>FPC internal compiler routine: WideStr_To_ShortStr</short>
</element>


<element name="fpc_widestr_to_widechararray">
<short>FPC internal compiler routine: widestr_to_widechararray</short>
</element>


<element name="fpc_WideStr_uint">
<short>FPC internal compiler routine: WideStr_uint</short>
</element>


<element name="fpc_widestr_Unique">
<short>FPC internal compiler routine: widestr_Unique</short>
</element>


<element name="fpc_Write_End">
<short>FPC internal compiler routine: Write_End</short>
</element>


<element name="fpc_Writeln_End">
<short>FPC internal compiler routine: Writeln_End</short>
</element>


<element name="fpc_Write_Text_AnsiStr">
<short>FPC internal compiler routine: Write_Text_AnsiStr</short>
</element>


<element name="fpc_Write_Text_Boolean">
<short>FPC internal compiler routine: Write_Text_Boolean</short>
</element>


<element name="fpc_Write_Text_Char">
<short>FPC internal compiler routine: Write_Text_Char</short>
</element>


<element name="fpc_Write_Text_Float">
<short>FPC internal compiler routine: Write_Text_Float</short>
</element>


<element name="fpc_write_text_int64">
<short>FPC internal compiler routine: write_text_int64</short>
</element>


<element name="fpc_Write_Text_Pchar_as_Array">
<short>FPC internal compiler routine: Write_Text_Pchar_as_Array</short>
</element>


<element name="fpc_Write_Text_PChar_As_Pointer">
<short>FPC internal compiler routine: Write_Text_PChar_As_Pointer</short>
</element>


<element name="fpc_write_text_qword">
<short>FPC internal compiler routine: write_text_qword</short>
</element>


<element name="fpc_Write_Text_ShortStr">
<short>FPC internal compiler routine: Write_Text_ShortStr</short>
</element>


<element name="fpc_Write_Text_SInt">
<short>FPC internal compiler routine: Write_Text_SInt</short>
</element>


<element name="fpc_Write_Text_UInt">
<short>FPC internal compiler routine: Write_Text_UInt</short>
</element>


<element name="fpc_write_text_variant">
<short>FPC internal compiler routine: write_text_variant</short>
</element>


<element name="fpc_Write_Text_WideChar">
<short>FPC internal compiler routine: Write_Text_WideChar</short>
</element>


<element name="fpc_Write_Text_WideStr">
<short>FPC internal compiler routine: Write_Text_WideStr</short>
</element>

<!-- function Visibility: default -->
<element name="Align">
<short>Return aligned version of an address</short>
<descr>
<var>Align</var> returns <var>Address</var>, aligned to <var>Alignment</var>
bytes.
</descr>
<errors>
None.
</errors>
</element>

<element name="ArrayStringToPPchar">
<short>Concert an array of string to an array of null-terminated strings</short>
<descr>
<p>
<var>ArrayStringToPPchar</var> creates an array of null-terminated strings
that point to strings which are the same as the strings in the array
<var>S</var>. The function returns a pointer to this array. The array and
the strings it contains must be disposed of after being used, because it 
they are allocated on the heap.
</p>
<p>
The <var>ReserveEntries</var> parameter tells <var>ArrayStringToPPchar</var>
to allocate room at the end of the array for another <var>ReserveEntries</var>
entries.
</p>
</descr>
<errors>
If not enough memory is available, an error may occur.
</errors>
<seealso>
<link id="StringToPPChar"/>
</seealso>
</element>

<element name="StringToPPChar">
<short>Split string in list of null-terminated strings</short>
<descr>
<p>
<var>StringToPPChar</var> splits the string <var>S</var> in words, replacing any
whitespace with zero characters. It returns a pointer to an array of pchars
that point to the first letters of the words in <var>S</var>. This array is terminated
by a <var>Nil</var> pointer.
</p>
<p>
The function does <em> not</em> add a zero character to the end of the string
unless it ends on whitespace.
</p>
<p>
The function reserves memory on the heap to store the array of <var>PChar</var>;
The caller is responsible for freeing this memory. 
</p>
<p>
This function is only available on certain platforms.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ArrayStringToPPchar"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="varempty">
<short>Variant type: <var>Empty</var> variant</short>
</element>

<!-- constant Visibility: default -->
<element name="varnull">
<short>Variant type: <link id="Null"/> variant </short>
</element>

<!-- constant Visibility: default -->
<element name="varsmallint">
<short>Variant type: smallint (8 bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varinteger">
<short>Variant type: Integer (32-bit)</short>
</element>

<!-- constant Visibility: default -->
<element name="varsingle">
<short>Variant type: Single float </short>
</element>

<!-- constant Visibility: default -->
<element name="vardouble">
<short>Variant type: Double float </short>
</element>

<!-- constant Visibility: default -->
<element name="varcurrency">
<short>Variant type: Currency </short>
</element>

<!-- constant Visibility: default -->
<element name="vardate">
<short>Variant type: Date </short>
</element>

<!-- constant Visibility: default -->
<element name="varolestr">
<short>Variant type: OLE string (widestring) </short>
</element>

<!-- constant Visibility: default -->
<element name="vardispatch">
<short>Variant type: dispatch interface </short>
</element>

<!-- constant Visibility: default -->
<element name="varerror">
<short>Variant type: Error type </short>
</element>

<!-- constant Visibility: default -->
<element name="varboolean">
<short>Variant type: Boolean type </short>
</element>

<!-- constant Visibility: default -->
<element name="varvariant">
<short>Variant type: Variant (arrays only) </short>
</element>

<!-- constant Visibility: default -->
<element name="varunknown">
<short>Variant type: Unknown </short>
</element>

<!-- constant Visibility: default -->
<element name="vardecimal">
<short>Variant type: Decimal (BCD) </short>
</element>

<!-- constant Visibility: default -->
<element name="varshortint">
<short>Variant type: Shortint (16 bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varbyte">
<short>Variant type: Byte (8 bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varword">
<short>Variant type: Word (16 bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varlongword">
<short>Variant type: Word (32 bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varint64">
<short>Variant type: Integer (64-Bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varqword">
<short>Variant type: Word (64-bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varstrarg">
<short>Variant type: String </short>
</element>

<!-- constant Visibility: default -->
<element name="varstring">
<short>Variant type: String </short>
</element>

<!-- constant Visibility: default -->
<element name="varany">
<short>Variant type: Any </short>
</element>

<!-- constant Visibility: default -->
<element name="vartypemask">
<short>Variant type: Mask to extract type </short>
</element>

<!-- constant Visibility: default -->
<element name="vararray">
<short>Variant type: variant Array </short>
</element>

<!-- constant Visibility: default -->
<element name="varbyref">
<short>Variant type: By reference </short>
</element>

<!-- constant Visibility: default -->
<element name="varword64">
<short>Variant type: Word (64-bit) </short>
</element>

<!-- alias type Visibility: default -->
<element name="tvartype">
<short>Type with size of variant type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararrayboundarray">
<short>Pointer to <link id="tvararrayboundarray"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararraycoorarray">
<short>Pointer to <link id="tvararraycoorarray"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararraybound">
<short>Pointer to <link id="tvararraybound"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararray">
<short>Pointer to <link id="TVarArray"/> type.</short>
</element>

<!-- record type Visibility: default -->
<element name="tvararraybound">
<short>Type describing variant array bounds.</short>
<descr>
<var>tvararraybound</var> is used to describe one dimension in a variant
array.
</descr>
<seealso>
<link id="tvararray"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tvararraybound.elementcount">
<short>Number of elements in this array dimension.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararraybound.lowbound">
<short>Lower bound of this array dimension (index of first element).</short>
</element>

<!-- record type Visibility: default -->
<element name="tvararray">
<short>Type describing variant array</short>
<descr>
<var>tvararray</var> is a record describing a variant array. It contains
some general data, followed by a number of <link id="TVarArrayBound"/>
records equal to the number of dimensions in the array (<var>dimcoun</var>).
</descr>
<seealso>
<link id="TVarArrayBound"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.dimcount">
<short>Number of dimensions</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.flags">
<short>Array flags.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.elementsize">
<short>Size of one element in the array.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.lockcount">
<short>Lock (reference) count of the array.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.data">
<short>Pointer to the array data.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.bounds">
<short>Array describing the bounds in the array.</short>
</element>

<!-- array type Visibility: default -->
<element name="tvararrayboundarray">
<short>array of <link id="tvararraybound"/> records.</short>
</element>

<!-- array type Visibility: default -->
<element name="tvararraycoorarray">
<short>Array of variant array coordinates</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="tvarop">
<short>Variant operation.</short>
<descr>
<var>tvarop</var> describes a variant operation. It is mainly used for the
variant manager to implement the various conversions and mathematical
operations on a variant.
</descr>
<seealso>
<link id="TVariantManager"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opadd">
<short>Variant operation: Addition.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opsubtract">
<short>Variant operation: Substraction</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opmultiply">
<short>Variant operation: multiplication</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opdivide">
<short>Variant operation: division</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opintdivide">
<short>Variant operation: integer divide</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opmodulus">
<short>Variant operation: Modulus</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opshiftleft">
<short>Variant operation: Shift left</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opshiftright">
<short>Variant operation: Shift right</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opand">
<short>Variant operation: Binary AND operation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opor">
<short>Variant operation: Binary OR operation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opxor">
<short>Variant operation: binary XOR operation.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcompare">
<short>Variant operation: Compare</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opnegate">
<short>Variant operation: negation.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opnot">
<short>Variant operation: Binary NOT operation.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpeq">
<short>Variant operation: Compare equal.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpne">
<short>Variant operation: Compare not equal</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmplt">
<short>Variant operation: Compare less than.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmple">
<short>Variant operation: Compare less than or equal to</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpgt">
<short>Variant operation: Compare larger than</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpge">
<short>Variant operation: Compare larger than or equal</short>
</element>

<!-- record type Visibility: default -->
<element name="tvardata">
<short>Variant record.</short>
<descr>
<var>TVarData</var> is a record representation of a variant. It contains the
internal structure of a variant and is handled by the various variant
handling routines.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vtype">
<short>Type of variant.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvardata">
<short>Pointer to <link id="TVarData"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pcalldesc">
<short>Pointer to <link id="TCallDesc"/> record.</short>
</element>

<!-- record type Visibility: default -->
<element name="tcalldesc">
<short>COM/OLE dispatch call argument description.</short>
<descr>
<var>tcalldesc</var> is used to encode the arguments to a dispatch call to 
an OLE dual interface. It is used on windows only. It describes the 
arguments to a call.
</descr>
</element>


<!-- variable Visibility: default -->
<element name="tcalldesc.calltype">
<short>Call type.</short>
</element>

<!-- variable Visibility: default -->
<element name="tcalldesc.argcount">
<short>Number of arguments to call.</short>
</element>

<!-- variable Visibility: default -->
<element name="tcalldesc.namedargcount">
<short>Number of named arguments in the call.</short>
</element>

<!-- variable Visibility: default -->
<element name="tcalldesc.argtypes">
<short>Types of arguments.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="tdispdesc">
<short>COM/OLE dispatch call description.</short>
<descr>
<var>tcalldesc</var> is used to encode a dispatch call to an OLE dispatch 
interface. It is used on windows only. It describes the dispath call call.
</descr>
<seealso>
<link id="tcalldesc"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="pdispdesc">
<short>Pointer to <link id="tdispdesc"/> record</short>
</element>

<!-- variable Visibility: default -->
<element name="tdispdesc.dispid">
<short>Dispatch ID</short>
</element>

<!-- variable Visibility: default -->
<element name="tdispdesc.restype">
<short>Result type.</short>
</element>

<!-- variable Visibility: default -->
<element name="tdispdesc.calldesc">
<short>Arguments description.</short>
</element>

<!-- record type Visibility: default -->
<element name="tvariantmanager">
<short>Record describing the variant manager.</short>
<descr>
<var>TVariantManager</var> describes the variant manager as expected by the
<link id="SetVariantManager"/> call.
</descr>
<seealso>
<link id="SetVariantManager"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoint">
<short>Called to convert a variant to an integer value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoint64">
<short>Called to convert a variant to an int64 value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoword64">
<short>Called to convert a variant to a word64 value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartobool">
<short>Called to convert a variant to a boolean value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoreal">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartocurr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartopstr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartolstr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartowstr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartointf">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartodisp">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartodynarray">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfrombool">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromint">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromint64">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromword64">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromreal">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfrompstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromlstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromwstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromintf">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromdisp">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromdynarray">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfrompstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfromlstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfromvar">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfromint">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varop">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.cmpop">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varneg">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varnot">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varinit">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varclear">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varaddref">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varcopy">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varcast">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varcastole">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.dispinvoke">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vararrayredim">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vararrayget">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vararrayput">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.writevariant">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.write0Variant">
<short>Called to perform a variant operation: </short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvariantmanager">
<short>Pointer to <link id="TVariantManager"/> record.</short>
</element>

<!-- procedure Visibility: default -->
<element name="GetVariantManager">
<short>Return the current variant manager.</short>
<descr>
<var>GetVariantManager</var> returns the current variant manager in
<var>varmgr</var>.
</descr>
<seealso>
<link id="IsVariantManagerSet"/>
<link id="SetVariantManager"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetVariantManager">
<short>Set the current variant manager.</short>
<descr>
<var>SetVariantManager</var> sets the variant manager to <var>varmgr</var>.
</descr>
<seealso>
<link id="IsVariantManagerSet"/>
<link id="GetVariantManager"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IsVariantManagerSet">
<short>Determine if variant manager is currently set.</short>
<descr>
<p>
<var>IsVariantManagerSet</var> determines whether the variant manager was
set to a correct variant manager. It returns <var>True</var> if it is, 
or <var>False</var> if it is not.
</p>
<p>
The routine checks all variant operation handlers, they should all be set correctly.
</p>
</descr>
<seealso>
<link id="SetVariantManager"/>
<link id="GetVariantManager"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="VarDispProc">
<short>Callback to perform dispatch interface procedure call by name.</short>
<descr>
<p>
<var>VarDispProc</var> is called by the compiler if it needs to perform an
interface call from a variant. For instance, the following call:
</p>
<code>
Var
  V : OleVariant;
begin
  V.OpenDocument('c:\temp\mydoc.doc');
end;  
</code>
<p>
is encoded by the compiler and passed to <var>VarDispProc</var>.
</p>
<p>
This pointer must be set by a routine that calls the OS COM handling
routines.
</p>
</descr>
<seealso>
<link id="DispCallByIDProc"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="DispCallByIDProc">
<short>Callback to perform dispatch interface procedure call by ID.</short>
<descr>
<p>
<var>VarDispProc</var> is called by the compiler if it needs to perform an
interface call from a variant which contains a dispatch interface. 
For instance, the following call:
</p>
<code>
Var
  V : OleVariant;
begin
  (V as IWord).OpenDocument('c:\temp\mydoc.doc');
end;
</code>    
<p>
where <var>IWord</var> is a dispatch interface is encoded by the compiler and 
passed to <var>DispCallByIDProc</var>.
</p>
<p>
This pointer must be set by a routine that calls the OS COM handling
routines.
</p>
</descr>
<seealso>
<link id="VarDispProc"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="Null">
<short>Null variant</short>
</element>

<!-- variable Visibility: default -->
<element name="Unassigned">
<short>Unassigned variant.</short>
</element>

<!-- record type Visibility: default -->
<element name="THeapStatus">
<short>Record describing current heap status.</short>
<descr>
<var>THeapStatus</var> is the record describing the current heap status. It
is returned by the <link id="GetHeapStatus"/> call.
</descr>
<seealso>
<link id="GetHeapStatus"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.MaxHeapSize">
<short>Biggest heap size used.</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.MaxHeapUsed">
<short>Biggest used part of heap memory.</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.CurrHeapSize">
<short>Current heap size. </short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.CurrHeapUsed">
<short>Current size of used heap memory.</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.CurrHeapFree">
<short>Current size of free heap memory.</short>
</element>

<!-- procedure Visibility: default -->
<element name="SysGetHeapStatus">
<short>System implementation of <link id="GetHeapStatus"/></short>
<descr>
<var>SysGetHeapStatus</var> is the system implementation of the <link
id="GetHeapStatus"/> call.
</descr>
<seealso>
<link id="GetHeapStatus"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="Heapsize">
<short>Current heap size</short>
<descr>
<var>HeapSize</var> returns the current heap size. The heap grows
dynamically (as allowed by the OS) and the <var>HeapSize</var> reflects the
current state of the heap.
</descr>
<seealso>
<link id="GetHeapStatus"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="TThreadID">
<short>Type for Thread-IDs</short>
<descr>
This is an opaque type, it can differ from operating system to operating
system.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="PRTLCriticalSection">
<short>Pointer to <link id="#rtl.system.TRTLCriticalSection"/> type.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TRTLCriticalSection" opaque="1">
<short>A critical section.</short>
<descr>
<var>TRTLCriticalSection</var> represents a critical section (a mutex). This is an opaque type, 
it can differ from operating system to operating system. No assumptions
should be made about it's structure or contents. 
</descr>
</element>

<!-- constant Visibility: default -->
<element name="InitProc">
<short>Initialization routine</short>
<descr>
<p>
<var>InitProc</var> is a routine that can be called after all units were
initialized. It can be set by units to execute code that can be initialized
after all units were initialized.
</p>
<remark>
When setting the value of <var>InitProc</var>, the previous value should
always be saved, and called when the installed initialization routine has
finished executing. 
</remark>
</descr>
<seealso>
<link id="ExitProc"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetProcessID">
<short>Get the current process ID</short>
<descr>
<var>GetProcessID</var> returns the current process ID. 
The meaning of the return value of this call is system dependent.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetThreadID"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetThreadID">
<short>Get the current Thread ID.</short>
<descr>
<var>GetThreadID</var> returns the current process ID. 
The meaning of the return value of this call is system dependent.
</descr>
<seealso>
<link id="GetProcessID"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="S_OK">
<short>Interface call result: OK</short>
</element>

<!-- constant Visibility: default -->
<element name="S_FALSE">
<short>Interface call result: Not OK</short>
</element>

<!-- constant Visibility: default -->
<element name="E_NOINTERFACE">
<short>Interface call result: Error: not an interface</short>
</element>

<!-- constant Visibility: default -->
<element name="E_UNEXPECTED">
<short>Interface call result: Unexpected error</short>
</element>

<!-- constant Visibility: default -->
<element name="E_NOTIMPL">
<short>Interface call result: Interface not implemented</short>
</element>

<!-- record type Visibility: default -->
<element name="TMethod">
<short>Record describing a method.</short>
<descr>
<var>TMethod</var> describes a general method pointer, and is used in
Run-Time Type Information handling.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TMethod.Code">
<short>Pointer to method code.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMethod.Data">
<short>Pointer to object instance.</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Framecount">
<short>Number of frames in the exception object</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Frames">
<short>Pointer to array of frame pointers</short>
</element>

<!-- constant Visibility: default -->
<element name="RaiseMaxFrameCount">
<short>Maximum number of frames to include in <link id="#rtl.system.TExceptObject">TExceptObject</link></short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.oppower">
<short>Variant operation: Power</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartotdatetime">
<short>Callback to convert a variant to a <var>TDatetime</var> value.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromtdatetime">
<short>Callback to convert a <var>TDateTime</var> value to a variant.</short>
</element> 

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromcurr">
<short>Callback to convert a variant to a currency value.</short>
</element>

<!-- constant Visibility: default -->
<element name="VarClearProc">
<short>Callback to clear a variant.</short>
</element>

<!-- constant Visibility: default -->
<element name="VarAddRefProc">
<short>Callback to increase reference count of a variant.</short>
</element>

<!-- constant Visibility: default -->
<element name="VarCopyProc">
<short>Callback to copy a variant</short>
</element>

<!-- constant Visibility: default -->
<element name="VarToLStrProc">
<short>Callback to convert a variant to a ansistring.</short>
</element>

<!-- constant Visibility: default -->
<element name="VarToWStrProc">
<short>Callback to convert a variant to a widestring.</short>
</element>

<!-- procedure Visibility: default -->
<element name="VarArrayRedim">
<short>Redimension a variant array</short>
<descr>
<var>VarArrayRedim</var> re-sizes the first dimension of the variant array
<var>A</var>, giving it a new high bound <var>HighBound</var>. 
Obviously, <var>A</var> must be a variant array for this function to work.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- array type Visibility: default -->
<element name="fpc_big_widechararray" skip="1">
<short>Internal type used by widestring routines. Do not use</short>
</element>

<!-- constant Visibility: default -->
<element name="DefaultStackSize">
<short>Default size for a new thread's stack (32k by default).</short>
</element>

<!-- alias type Visibility: default -->
<element name="PEventState">
<short>Pointer to EventState, which is an opaque type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PRTLEvent">
<short>Pointer to RTLEvent, which is an opaque type.</short>
</element>

<!-- function type Visibility: default -->
<element name="TThreadFunc">
<short>Thread function prototype</short>
</element>

<!-- procedure type Visibility: default -->
<element name="trtlmethod">
<short>Callback type for synchronization event.</short>
</element>

<!-- function type Visibility: default -->
<element name="TBeginThreadHandler">
<short>Callback for thread start in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TEndThreadHandler">
<short>Callback for thread end in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TThreadHandler">
<short>Generic thread handler callback for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TThreadSwitchHandler">
<short>Callback type for thread switch in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TWaitForThreadTerminateHandler">
<short>Callback type for thread termination in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TThreadSetPriorityHandler">
<short>Callback type for thread priority setting in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TThreadGetPriorityHandler">
<short>Callback type for thread priority getting in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TGetCurrentThreadIdHandler">
<short>Callback type for retrieving thread ID in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TCriticalSectionHandler">
<short>Generic callback type for critical section handling in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TInitThreadVarHandler">
<short>Threadvar initialization callback type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TRelocateThreadVarHandler">
<short>Threadvar relocalization callback type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TAllocateThreadVarsHandler">
<short>Threadvar allocation callback type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TReleaseThreadVarsHandler">
<short>Threadvar release callback type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TBasicEventHandler">
<short>Generic callback type for handling eventstate in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TBasicEventWaitForHandler">
<short>Wait for basic event callback type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TBasicEventCreateHandler">
<short>callback type for creating eventstate in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TRTLEventHandler">
<short>Generic TRTLEvent handling type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TRTLEventHandlerTimeout">
<short>TRTLEvent timeout handling type for <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- function type Visibility: default -->
<element name="TRTLCreateEventHandler">
<short>Callback type for creating a <var>TRTLEvent</var> type in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TRTLEventSyncHandler">
<short>Callback type for event sycnhronization in <link id="#rtl.system.TThreadManager">TThreadManager</link>.</short>
</element>

<!-- record type Visibility: default -->
<element name="TThreadManager">
<short>Thread manager record.</short>
<descr>
<p>
<var>TThreadManager</var> is a record that contains all callbacks needed for the thread handling
routines of the Free Pascal Run-Time Library. The thread manager can be set
by the <link id="SetThreadManager"/> procedure, and the current thread
manager can be retrieved with the <link id="GetThreadManager"/> procedure.
</p>
<p>
The Windows RTL will set the thread manager automatically to a system thread
manager, based on the Windows threading routines. Unix operating systems
provide a unit <file>cthreads</file> which implements threads based on the C
library POSIX thread routines. It is not included by default, because it
would make the system unit dependent on the C library.
</p>

<p>
For more information about thread programming, see the programmer's guide.
</p>
</descr>
<seealso>
<link id="GetThreadManager"/>
<link id="SetThreadManager"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.InitManager">
<short>Initialize the thread manager.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.DoneManager">
<short>Clean up the thread manager.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BeginThread">
<short>Start a new thread.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.EndThread">
<short>End the current thread.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.SuspendThread">
<short>Suspend a running thread.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.ResumeThread">
<short>Resumt a suspended thread.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.KillThread">
<short>Kill a running thread.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.ThreadSwitch">
<short>Cause a threadswitch.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.WaitForThreadTerminate">
<short>Wait for a thread to stop.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.ThreadSetPriority">
<short>Set thread priority</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.ThreadGetPriority">
<short>Get thread priority.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.GetCurrentThreadId">
<short>Get current thread ID</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.InitCriticalSection">
<short>Initialize a critical section.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.DoneCriticalSection">
<short>Free a critical section</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.EnterCriticalSection">
<short>Enter a critical section</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.LeaveCriticalSection">
<short>leave a critical section.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.InitThreadVar">
<short>Initialize a thread variable.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RelocateThreadVar">
<short>Relocate a thread variable.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.AllocateThreadVars">
<short>Allocate thread variables.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.ReleaseThreadVars">
<short>Release thread variables.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BasicEventCreate">
<short>Create a basic event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BasicEventDestroy">
<short>Destroy a basic event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BasicEventResetEvent">
<short>Reset a basic event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BasicEventSetEvent">
<short>Set a basic event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.BasiceventWaitFOr">
<short>Wait for a basic event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventCreate">
<short>Create an RTL event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventDestroy">
<short>Free an RTL event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventSetEvent">
<short>Set an RTL event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventResetEvent">
<short>Reset an RTL event</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventStartWait">
<short>Wait for an RTL event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventWaitFor">
<short>Wait for an RTL event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventSync">
<short>Synchronize an RTL event.</short>
</element>

<!-- variable Visibility: default -->
<element name="TThreadManager.RTLEventWaitForTimeout">
<short>Wait for RTL event, with timeout.</short>
</element>

<!-- function Visibility: default -->
<element name="GetThreadManager">
<short>Return the current thread manager</short>
<descr>
<p>
<var>GetThreadManager</var> returns the currently used thread manager in
<var>TM</var>.
</p>
<p>
For more information about thread programming, see the programmer's guide.
</p>
</descr>
<seealso>
<link id="SetThreadManager"/>
<link id="TThreadManager"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SetThreadManager">
<short>Set the thread manager, optionally return the current thread manager.</short>
<descr>
<p>
<var>SetThreadManager</var> sets the thread manager to <var>NewTM</var>.
If <var>OldTM</var> is given, <var>SetThreadManager</var> uses it to return the
previously used thread manager.
</p>
<p>
The function returns <var>True</var> if the threadmanager was set
succesfully, <var>False</var> if an error occurred.
</p>
<p>
For more information about thread programming, see the programmer's guide.
</p>
</descr>
<errors>
If an error occurred cleaning up the previous manager, or an error occurred
initializing the new manager, <var>False</var> is returned.
</errors>
<seealso>
<link id="GetThreadManager"/>
<link id="TThreadManager"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetNoThreadManager">
<short>Clear the threadmanager</short>
<descr>
<var>SetNoThreadManager</var> clears the thread manager by setting the
thread manager to an empty thread manager record.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="InitThread">
<short>Initialize a thread</short>
<descr>
Do not use, this is used internally by the thread manager.
</descr>
</element>

<!-- function Visibility: default -->
<element name="BeginThread">
<short>Start a new thread.</short>
<descr>
<p>
<var>BeginThread</var> starts a new thread and executes
<var>ThreadFunction</var> in the new thread. If <var>P</var> is specified,
then it is passed to <var>ThreadFunction</var>. If <var>ThreadId</var> is
specified, it is filled with the thread ID of the newly started thread.
</p>
<p>
The function returns zero on succes.
</p>
</descr>
<errors>
On error, a nonzero value is returned.
</errors>
<seealso>
<link id="EndThread"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="EndThread">
<short>End the current thread.</short>
<descr>
<p>
<var>EndThread</var> ends the current thread. If <var>ExitCode</var> is
supplied, it is returned as the exit code for the thread to a function
waiting for the thread to terminate (<link id="WaitForThreadTerminate"/>).
If it is omitted, zero is used.
</p>
<p>
This function does not return.
</p>
</descr>
<seealso>
<link id="WaitForThreadTerminate"/>
<link id="BeginThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SuspendThread">
<short>Suspend a running thread.</short>
<descr>
<p>
<var>SuspendThread</var> suspends a running thread. The thread is identified
with it's handle or ID <var>threadHandle</var>.
</p>
<p>
The function returns zero if succesful. A nonzero return value indicates
failure.
</p>
</descr>
<errors>
If a failure occurred, a nonzero result is returned. The meaning is systemm
dependent.
</errors>
<seealso>
<link id="ResumeThread"/>
<link id="KillThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ResumeThread">
<short>Resume a suspended thread.</short>
<descr>
<p>
<var>ResumeThread</var> causes a suspended thread (using <link
id="SuspendThread"/>) to resume it's execution. The thread is 
identified with it's handle or ID <var>threadHandle</var>.
</p>
<p>
The function returns zero if succesful. A nonzero return value indicates
failure.
</p>
</descr>
<errors>
If a failure occurred, a nonzero result is returned. The meaning is systemm
dependent.
</errors>
<seealso>
<link id="SuspendThread"/>
<link id="KillThread"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="ThreadSwitch">
<short>Signal possibility of thread switch</short>
<descr>
<p>
<var>ThreadSwitch</var> signals the operating system that the thread should
be suspended and that another thread should be executed.
</p>
<p>
This call is a hint only, and may be ignored.
</p>
</descr>
<seealso>
<link id="SuspendThread"/>
<link id="ResumeThread"/>
<link id="KillThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="KillThread">
<short>Kill a running thread</short>
<descr>
<p>
<var>KillThread</var> causes a running thread to be aborted. The thread is
identified by it's handle or ID <var>threadHandle</var>.
</p>
<p>
The function returns zero if succesful. A nonzero return value indicates
failure.
</p>
</descr>
<errors>
If a failure occurred, a nonzero result is returned. The meaning is systemm
dependent.
</errors>
<seealso>
<link id="WaitForThreadTerminate"/>
<link id="EndThread"/>
<link id="SuspendThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="WaitForThreadTerminate">
<short>Wait for a thread to terminate.</short>
<descr>
<p>
<var>WaitForThreadTerminate</var> waits for a thread to finish it's
execution. The thread is identified by it's handle or ID
<var>threadHandle</var>. If the thread does not exit within <var>TimeoutMs</var>
milliseconds, the function will return with an error value.
</p>
<p>
The function returns the exit code of the thread.
</p>
</descr>
<seealso>
<link id="EndThread"/>
<link id="KillThread"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ThreadSetPriority">
<short>Set the priority of a thread.</short>
<descr>
<var>ThreadSetPriority</var> sets the priority of thread <var>TThreadID</var> to <var>Prio</var>.
Priority is a value between -15 and 15. 
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ThreadGetPriority"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ThreadGetPriority">
<short>Return the priority of a thread.</short>
<descr>
<var>ThreadGetPriority</var> returns the priority of thread
<var>TThreadID</var> to <var>Prio</var>. The returned priority
is a value between -15 and 15.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ThreadSetPriority"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetCurrentThreadId">
<short>Return the id of the currently running thread.</short>
<descr>
<var>GetCurrentThreadId</var> returns the ID of the currently running
thread. It can be used in calls such as <link id="KillThread"/> or 
<link id="ThreadSetPriority"/>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="KillThread"/>
<link id="ThreadSetPriority"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="InitCriticalSection">
<short>Initialize a critical section</short>
<descr>
<p>
<var>InitCriticalSection</var> initializes a critical section <var>CS</var>
for use. Before using a critical section with <link id="EnterCriticalsection"/> or
<link id="LeaveCriticalsection"/> the critical section should be initialized
with <var>InitCriticalSection</var>.
</p>
<p>
When a critical section is no longer used, it should be disposed of with
<link id="DoneCriticalsection"/>
</p>
</descr>
<seealso>
<link id="DoneCriticalsection"/>
<link id="EnterCriticalsection"/>
<link id="LeaveCriticalsection"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="DoneCriticalsection">
<short>Clean up a critical section.</short>
<descr>
<var>DoneCriticalsection</var> cleans up the critical section <var>CS</var>.
After a call to <var>DoneCriticalsection</var>, the critical section can no
longer be used with <link id="EnterCriticalsection"/> or
<link id="LeaveCriticalsection"/>,  unless it is again initialized with <link
id="InitCriticalSection"/>
</descr>
<seealso>
<link id="InitCriticalsection"/>
<link id="EnterCriticalsection"/>
<link id="LeaveCriticalsection"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="EnterCriticalSection">
<short>Enter a critical section</short>
<descr>
<p>
<var>EnterCriticalSection</var> will suspend the current thread if another
thread has currently entered the critical section. When the other thread has
left the critical section (through <link id="LeaveCriticalSection"/>), the
current thread resumes execution. The result is that only 1 thread is
executing code which is protected by a <var>EnterCriticalsection</var> and 
<var>LeaveCriticalSection</var> pair.
</p>
<p>
The critical section must have been initialized with <link id="InitCriticalSection"/>
prior to a call to <var>EnterCriticalsection</var>.
</p>
<p>
A call to <var>EnterCriticalsection</var> must always be matched by a call
to <link id="LeaveCriticalSection"/>. To avoid problems, it is best to
include the code to be execute in a <var>try...finally</var> block, as
follows:
</p>
<code>
  EnterCriticalSection(Section);
  Try 
    // Code to be protected goes here.
  Finally
    LeaveCriticalSection(Section);
  end;
</code>
<p>
For performance reasons it is best to limit the code between the entering
and leaving of a critical section as short as possible.
</p>
</descr>
<seealso>
<link id="InitCriticalsection"/>
<link id="DoneCriticalsection"/>
<link id="LeaveCriticalsection"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="LeaveCriticalsection">
<short>Leave a critical section</short>
<descr>
<p>
<var>LeaveCriticalSection</var> signals that the current thread is exiting
the critical section <var>CS</var> it has entered with <link id="EnterCriticalSection"/>.
</p>
<p>
The critical section must have been initialized with <link id="InitCriticalSection"/>
prior to a call to <var>EnterCriticalsection</var> and <var>LeaveCriticalSection</var>.
</p>
</descr>
<seealso>
<link id="InitCriticalsection"/>
<link id="DoneCriticalsection"/>
<link id="EnterCriticalsection"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="BasicEventCreate">
<short>Obsolete. Don't use</short>
<descr>
<var>BasicEventCreate</var> is obsolete, use <link id="RTLEventCreate"/>
instead.
</descr>
<seealso>
<link id="RTLEventCreate"/></seealso>
</element>

<!-- procedure Visibility: default -->
<element name="basiceventdestroy">
<short>Obsolete. Don't use</short>
<descr>
<var>basiceventdestroy</var> is obsolete. Use <link id="RTLEventDestroy"/>
instead.
</descr>
<seealso>
<link id="RTLEventDestroy"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="basiceventResetEvent">
<short>Obsolete. Don't use</short>
<descr>
<var>basiceventResetEvent</var> is obsolete. Use <link id="RTLEventResetEvent"/>
instead.
</descr>
<seealso>
<link id="RTLEventResetEvent"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="basiceventSetEvent">
<short>Obsolete. Don't use</short>
<descr>
<var>basiceventSetEvent</var> is obsolete. Use <link id="RTLEventSetEvent"/>
instead.
</descr>
<seealso>
<link id="RTLEventSetEvent"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="basiceventWaitFor">
<short>Obsolete. Don't use</short>
<descr>
<var>basiceventwaitfor</var> is obsolete. Use <link id="RTLEventWaitFor"/>
instead.
</descr>
<seealso>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="RTLEventCreate">
<short>Create a new RTL event</short>
<descr>
<p>
<var>RTLEventCreate</var> creates and initializes a new RTL event.  RTL
events are used to notify other threads that a certain condition is met, 
and to notify other threads of condition changes (conditional variables).
</p>
<p>
The function returns an initialized RTL event, which must be disposed of
with <link id="RTLEventdestroy"/>
</p>
<p>
<var>RTLEvent</var> is used mainly for the synchronize method.
</p>
</descr>
<seealso>
<link id="RTLEventDestroy"/>
<link id="RTLEventSet"/>
<link id="RTLEventReSet"/>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventdestroy">
<short>Destroy a RTL Event</short>
<descr>
<var>RTLeventdestroy</var> destroys the RTL event <var>State</var>.
After a call to <var>RTLeventdestroy</var>, the <var>State</var> RTL event
may no longer be used.
</descr>
<seealso>
<link id="RTLEventCreate"/>
<link id="RTLEventReset"/>
<link id="RTLEventSet"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventSetEvent">
<short>Notify threads of the event.</short>
<descr>
<var>RTLeventSetEvent</var> notifies other threads which are listening, 
that the event has occurred.
</descr>
<seealso>
<link id="RTLEventCreate"/>
<link id="RTLEventResetEvent"/>
<link id="RTLEventDestroy"/>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventResetEvent">
<short>Reset an event</short>
<descr>
<var>RTLeventSetEvent</var> notifies other threads which are listening,
that the event has occurred.
</descr>
<seealso>
<link id="RTLEventCreate"/>
<link id="RTLEventDestroy"/>
<link id="RTLEventSetEvent"/>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventStartWait">
<short>Prepare the event for waiting.</short>
<descr>
<p>
<var>RTLeventResetEvent</var> signals that a thread is ready to start
waiting on an event <var>state</var>. No event can be posted until a thread explicitly 
starts waiting on the event using <link id="RTLEventWaitFor"/>.
</p>
</descr>
<seealso>
<link id="RTLEventCreate"/>
<link id="RTLEventDestroy"/>
<link id="RTLEventSetEvent"/>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventWaitFor">
<short>Wait for an event.</short>
<descr>
<p>
<var>RTLeventWaitFor</var> suspends the thread till the event occurs. The
event will occur when another thread calls <link id="RTLEventSetEvent"/> on
<var>State</var>.
</p>
<p>
By default, the thread will be suspended indefinitely. However, if
<var>TimeOut</var> is specified, then the thread will resume after timeout
milliseconds have elapsed.
</p>
</descr>
<seealso>
<link id="RTLEventCreate"/>
<link id="RTLEventDestroy"/>
<link id="RTLEventSetEvent"/>
<link id="RTLEventWaitFor"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RTLeventsync">
<short>Obsolete. Don't use</short>
<descr>
<var>RTLeventsync</var> is obsolete, don't use it.
</descr>
</element>

<element name="ThreadingAlreadyUsed">
<short>Internal constant for the threading system. Don't use.</short>
</element>



<!-- constant Visibility: default -->
<element name="CtrlZMarksEOF">
<short>Determine whether CTRL-Z marks the end of file.</short>
<descr>
<p>
<var>CtrlZMarksEOF</var> indicates whether on this system, an
<var>CTRL-Z</var> character (ordinal 26) in a file marks the 
end of the file. This is <var>False</var> on most systems except on DOS.
</p>
<p>
To get DOS-compatible behaviour, this constant can be set to <var>True</var>
</p>
</descr>
<seealso>
<link id="LineEnding"/>
<link id="SetTextLineEnding"/>
</seealso>
</element>

<element name="SIGSTKSZ" skip="1"/>


<element name="AnsiToUtf8">
<short>Convert ansi string to UTF-8 string</short>
<descr>
<var>AnsiToUtf8</var> converts the ansistring <var>S</var> to a WideString
in UTF-8 format.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Utf8toAnsi"/>
</seealso>
</element>


<element name="DefaultAnsi2WideMove">
<short>Standard implementation of Ansi to Widestring conversion routine</short>
<descr>
<var>DefaultAnsi2WideMove</var> simply copies each character of the
null-terminated ansi-string <var>Source</var> to the corresponding WideChar
in <var>Dest</var>. At most <var>Len</var> characters will be copied.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="DefaultWide2AnsiMove"/>
</seealso>
</element>


<element name="DefaultWide2AnsiMove">
<short>Standard implementation of Widestring to Ansi conversion routine</short>
<descr>
<var>DefaultWide2AnsiMove</var> simply copies each character from
<var>Source</var> having an ordinal value of less than 255 to the
corresponding character in <var>Dest</var>. Characters having an 
ordinal valuelarger than 255 will be replaced by question marks.
At most <var>Len</var> characters will be copied.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="DefaultAnsi2WideMove"/>
</seealso>
</element>


<element name="DynArraySetLength">
<short>Set the length of a dynamic array</short>
<descr>
<p>
<var>DynArraySetLength</var> sets the length of the dynamical array
<var>a</var> to the first <var>dimCnt</var> lengths specified in the 
array <var>lengthVec</var>. The dynamical array type is described in
<var>typeInfo</var> which points to a record of type <link
id="TDynArrayTypeInfo"/>
</p>
<p>
It should never be necessary to call this function directly, the 
standard <link id="SetLength"/> function should be used instead.
</p>
</descr>
<errors>
If an invalid pointer is specified, an error may occur.
</errors>
<seealso>
<link id="SetLength"/>
<link id="tdynarraytypeinfo"/>
</seealso>
</element>



<element name="GetFPCHeapStatus">
<short>Return FPC heap manager status information</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>




<element name="HGLOBAL">
<short>Windows compatibility type for use in resources</short>
<descr>
This is an opaque type.
</descr>
</element>


<element name="HINSTANCE">
<short>Windows compatibility type for use in resources</short>
<descr>
This is an opaque type.
</descr>
</element>


<element name="HMODULE">
<short>Windows compatibility type for use in resources</short>
<descr>
This is an opaque type.
</descr>
</element>


<element name="IDispatch">
<short>Dispatch interface</short>
<descr>
<var>IDispatch</var> is the pascal definition of the Windows Dispatch
interface definition.
</descr>
<seealso>
<link id="IUnknown"/>
</seealso>
</element>


<element name="IDispatch.GetIDsOfNames">
<short>Return IDs of named procedures</short>
<descr>
Return the ID of a procedure.
</descr>
</element>


<element name="IDispatch.GetTypeInfo">
<short>Return type information about properties</short>
</element>


<element name="IDispatch.GetTypeInfoCount">
<short>Return number of properties.</short>
</element>


<element name="IDispatch.Invoke">
<short>Invoke a dispatch method</short>
</element>


<element name="IInterface">
<short>Basic interface for all COM based interfaces</short>
<descr>
<var>IInterface</var> is the basic interface from which all COM style
interfaces descend.
</descr>
<seealso>
<link id="IDispatch"/>
<link id="IInvokable"/>
</seealso>
</element>


<element name="IInvokable">
<short>Interface with RTTI associated with it.</short>
<descr>
<var>IInvokable</var> is a descendent of <link id="IInterface"/>, compiled
in the <var>{$M+}</var> state, so Run-Time Type Information (RTTI) is
generated for it.
</descr>
<seealso>
<link id="IDispatch"/>
<link id="IInterface"/>
</seealso>
</element>


<element name="InitThreadVars">
<short>Initialize threadvars </short>
<descr>
This routine should be called when threading is started. It is called by the
compiler and should never be called manually, only from a thread manager.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TThreadManager"/>
<link id="TThreadManager.InitThreadVar"/>
</seealso>
</element>


<element name="IUnknown">
<short>Basic interface for all COM-based interfaces</short>
<descr>
<var>IUnknown</var> is defined by windows. It's the basic interface which
all COM objects must implement. The definition does not contain any code.
</descr>
<seealso>
<link id="IInterface"/>
<link id="IDispatch"/>
<link id="IInvokable"/>
</seealso>
</element>


<element name="IUnknown._AddRef">
<short>Increase reference count of the interface</short>
<seealso>
<link id="IUnknown._Release"/>
</seealso>
</element>


<element name="IUnknown.QueryInterface">
<short>Return pointer to VMT table of interface </short>
</element>


<element name="IUnknown._Release">
<short>Decrease reference count of the interface</short>
<seealso>
<link id="IUnknown._AddRef"/>
</seealso>
</element>

<element name="FindResource">
<short>Locate a resource and return a handle to it.</short>
<descr>
<var>FindResource</var> searches for a resource with name
<var>ResourceName</var> and of type <var>ResourceType</var> 
in the executable or library identified by <var>ModuleHandle</var>.
It returns a <var>TResourceHandle</var> which can be used to load the
resource with <link id="LoadResource"/>.
</descr>
<errors>
None. In case the resource was not found, 0 is returned.
</errors>
<seealso>
<link id="FreeResource"/>
<link id="LoadResource"/>
<link id="SizeofResource"/>
<link id="LockResource"/>
<link id="UnlockResource"/>
<link id="FreeResource"/>
</seealso>
</element>


<element name="FreeResource">
<short>Free a loaded resource</short>
<descr>
<var>FreeResource</var> unloads the resource identified by
<var>ResData</var> from memory. The resource must have been loaded by <link
id="LoadResource"/>. It returns <var>True</var> if the operation was
succesful, <var>False</var> otherwise.
</descr>
<errors>
On error, <var>False</var> is returned.
</errors>
<seealso>
<link id="FindResource"/>
<link id="LoadResource"/>
<link id="SizeofResource"/>
<link id="LockResource"/>
<link id="UnlockResource"/>
<link id="FreeResource"/>
</seealso>
</element>



<element name="LoadResource">
<short>Load a resource for use</short>
<descr>
<p>
<var>LoadResource</var> loads a resource identified by <var>ResHandle</var>
from a module identified by <var> ModuleHandle</var>into memory. It returns
a handle to the resource.
</p>
<p>
Loaded resources must be unloaded again using the <link id="FreeResource"/>
function.
</p>
</descr>
<errors>
On error, 0 is returned.
</errors>
<seealso>
<link id="FindResource"/>
<link id="FreeResource"/>
<link id="SizeofResource"/>
<link id="LockResource"/>
<link id="UnlockResource"/>
<link id="FreeResource"/>
</seealso>
</element>


<element name="LockResource">
<short>Lock a resource</short>
<descr>
<p>
<var>LockResource</var> locks a resource previously loaded by
<var>LoadResource</var> into memory. This means that any attempt to modify
the resource will fail while it is locked. The function returns a pointer to
the resource location in memory.
</p>
<p>
The resource can be freed again using the <link id="UnlockResource"/>
function.
</p>
</descr>
<errors>
if the function fails, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="FindResource"/>
<link id="FreeResource"/>
<link id="SizeofResource"/>
<link id="LoadResource"/>
<link id="UnlockResource"/>
<link id="FreeResource"/>
</seealso>
</element>

<element name="SizeofResource">
<short>Return the size of a particular resource</short>
<descr>
<var>SizeOfResource</var> returns the size of the resource identified by
<var>ResHandle</var> in module identified by <var>ModuleHandle</var>. 
<var>ResHandle</var> should be obtained from a call to <link id="LoadResource"/>
</descr>
<errors>
In case of an error, 0 is returned.
</errors>
<seealso>
<link id="FindResource"/>
<link id="FreeResource"/>
<link id="LoadResource"/>
<link id="LockResource"/>
<link id="UnlockResource"/>
<link id="FreeResource"/>
</seealso>
</element>

<element name="UnlockResource">
<short>Unlock a previously locked resource</short>
<descr>
<var>UnlockResource</var> unlocks a previously locked resource. Note that
this function does not exist on windows, it's only needed on other
platforms.
</descr>
<errors>
The function returns <var>False</var> if it failed.
</errors>
<seealso>
<link id="FindResource"/>
<link id="FreeResource"/>
<link id="SizeofResource"/>
<link id="LoadResource"/>
<link id="lockResource"/>
<link id="FreeResource"/>
</seealso>
</element>


<element name="MAKEINTRESOURCE">
<short>Alias for the <link id="#rtl.system.PChar">PChar</link> type.</short>
</element>


<element name="MaxKeptOSChunks">
<short>Maximum number of OS chunks to be kept in memory</short>
<descr>
<var>MaxKeptOSChunks</var> tells the heap manager how many free 
chunks of OS-allocated memory it should keep in memory. When freeing memory,
it can happen that a memory block obtained from the OS is completely free.
If more than <var>MaxKeptOSChunks</var> such blocks are free, then the heap
manager will return them to the OS, to reduce memory requirements.
</descr>
<seealso>
<link id="FreeMem"/>
</seealso>
</element>


<element name="MaxPathLen">
<short>Constant defining the maximum length of filenames (including path)</short>
<descr>
This constant is system dependent.
</descr>
</element>


<element name="BEtoN">
<short>Convert Big Endian-ordered integer to Native-ordered integer</short>
<descr>
<var>BEToN</var> will rearrange the bytes in a Big-Endian number to 
the native order for the current processor. That is, for a big-endian 
processor, it will do nothing, and for a little-endian processor, 
it will invert the order of the bytes.
</descr>
<seealso>
<link id="LEtoN"/>
<link id="NtoBE"/>
<link id="NtoLE"/>
</seealso>
</element>


<element name="LEtoN">
<short>Convert Little Endian-ordered integer to Native-ordered integer</short>
<descr>
<var>LEToN</var> will rearrange the bytes in a Little-Endian number to 
the native order for the current processor. That is, for a little-endian 
processor, it will do nothing, and for a big-endian processor, 
it will invert the order of the bytes.
</descr>
<seealso>
<link id="BEtoN"/>
<link id="NtoBE"/>
<link id="NtoLE"/>
</seealso>
</element>

<element name="NtoBE">
<short>Convert Native-ordered integer to a Big Endian-ordered integer</short>
<descr>
<var>NToBE</var> will rearrange the bytes in a natively-ordered number to 
the Big-Endian order. That is, for a Little-Endian processor, it will 
invert the order of the bytes and for a big-endian processor, it will do
nothing.
</descr>
<seealso>
<link id="BEtoN"/>
<link id="LEtoN"/>
<link id="NtoLE"/>
</seealso>
</element>


<element name="NtoLE">
<short>Convert Native-ordered integer to a Little Endian-ordered integer</short>
<descr>
<var>NToLE</var> will rearrange the bytes in a natively-ordered number to 
the little-Endian order. That is, for a Big-Endian processor, it will 
invert the order of the bytes and for a Little-Endian processor, it will do
nothing.
</descr>
<seealso>
<link id="BEtoN"/>
<link id="LEtoN"/>
<link id="NtoBE"/>
</seealso>
</element>


<element name="PDispatch">
<short>Pointer to <link id="#rtl.system.IDispatch">IDispatch</link> interface type</short>
</element>


<element name="PDynArrayTypeInfo">
<short>Pointer to <link id="#rtl.system.tdynarraytypeinfo">TDynArrayTypeInfo</link> type.</short>
</element>


<element name="PPDispatch">
<short>Pointer to <link id="#rtl.system.PDispatch">PDispatch</link> pointer type</short>
</element>


<element name="PPUnknown">
<short>Pointer to untyped pointer</short>
</element>


<element name="PUnknown">
<short>Untyped pointer</short>
</element>


<element name="PWideString">
<short>Pointer to widestring type</short>
</element>


<element name="RT_ACCELERATOR">
<short>Constant identifying an accelerator resouce</short>
</element>


<element name="RT_BITMAP">
<short>Constant identifying a bitmap resource</short>
</element>


<element name="RT_CURSOR">
<short>Constant identifying a cursor resource</short>
</element>


<element name="RT_DIALOG">
<short>Constant identifying a dialog resource</short>
</element>


<element name="RT_FONT">
<short>Constant identifying a font resource</short>
</element>


<element name="RT_FONTDIR">
<short>Constant identifying a font directory resource</short>
</element>


<element name="RT_GROUP_CURSOR">
<short>Constant identifying a group cursor resource</short>
</element>


<element name="RT_GROUP_ICON">
<short>Constant identifying a group icon resource</short>
</element>


<element name="RT_ICON">
<short>Constant identifying an icon resource</short>
</element>


<element name="RT_MENU">
<short>Constant identifying a menu resource</short>
</element>


<element name="RT_MESSAGETABLE">
<short>Constant identifying a message data resource</short>
</element>


<element name="RT_RCDATA">
<short>Constant identifying a binary data resource</short>
</element>


<element name="RT_STRING">
<short>Constant identifying a string table resource</short>
</element>


<element name="RT_VERSION">
<short>Constant identifying a version info resource</short>
</element>


<element name="RuntimeErrorExitCodes">
<short>Mapping between runtime-error constants and program exit codes</short>
<descr>
This array is used by the <link id="Error"/> routine to to convert a 
<link id="TRuntimeError"/> enumeration type to a process exit code.
</descr>
<seealso>
<link id="Error"/>
</seealso>
</element>


<element name="SafeCallErrorProc">
<short>Error handler for safecall errors</short>
<descr>
<var>SafeCallErrorProc</var> is a Handler called in case of a 
safecall calling convention error. <var>Error</var> is the error 
number (passed by the Windows operating system) and <var>Addr</var> is the address where the 
error occurred.
</descr>
<seealso>
<link id="TSafeCallErrorProc"/>
</seealso>
</element>

<element name="GetWideStringManager">
<short>Return a copy of the currently active widestring manager.</short>
<descr>
<p>
<var>GetWideStringManager</var> returns a copy of the currently active 
heap manager in <var>Old</var>
</p>
<p>
WideStrings are implemented in different ways on different platforms. 
Therefore, the Free Pascal Runtime library has no fixed implementation of
widestring routines. Instead, it defines a WideString manager record, 
with callbacks that can be set to an implementation which is most 
efficient on the current platform. On windows, standard Windows 
routines will be used. On Unix and Linux, an implementation based on the 
C library is available (in unit <file>cwstrings</file>).
</p>
<p>
It is possible to implement a custom widestring manager, optimized for 
the current application, without having to recompile the complete Run-Time Library.
</p>
</descr>
<seealso>
<link id="SetWideStringManager"/>
<link id="TWideStringManager"/>
</seealso>
</element>

<element name="SetWideStringManager">
<short>Set the widestring manager</short>
<descr>
<p>
<var>SetWideStringManager</var> sets the current widestring manager to <var>New</var>.
Optionally, it returns the currently active widestring manager in <var>Old</var>.
</p>
<p>
WideStrings are implemented in different ways on different platforms. 
Therefore, the Free Pascal Runtime library has no fixed implementation of
widestring routines. Instead, it defines a WideString manager record, 
with callbacks that can be set to an implementation which is most 
efficient on the current platform. On windows, standard Windows 
routines will be used. On Unix and Linux, an implementation based on the 
C library is available (in unit <file>cwstrings</file>).
</p>
<p>
It is possible to implement a custom widestring manager, optimized for 
the current application, without having to recompile the complete Run-Time Library.
</p>
</descr>
<errors>
</errors>
<seealso>
<link id="TWideStringManager"/>
</seealso>
</element>

<element name="TWideStringManager">
<short>Record containing the various callbacks of the widestring manager.</short>
<descr>
<var>TWideStringManager</var> contains the definition of the widestring manager.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TWideStringManager.Wide2AnsiMoveProc">
<short>Convert an AnsiString to a WideString</short>
</element>

<element name="TWideStringManager.Ansi2WideMoveProc">
<short>Convert a WideString to an AnsiString</short>
</element>

<element name="TWideStringManager.UpperWideStringProc">
<short>Convert a widestring to all-uppercase</short>
</element>

<element name="TWideStringManager.LowerWideStringProc">
<short>Convert a widestring to all-lowercase</short>
</element>

<element name="TWideStringManager.CompareWideStringProc">
<short>Compare 2 widestrings, case-sensitive</short>
</element>

<element name="TWideStringManager.CompareTextWideStringProc">
<short>Compare 2 widestrings, case-insensitive</short>
</element>

<element name="TWideStringManager.CharLengthPCharProc">
<short>Return the length, in characters, of a widestring</short>
</element>

<element name="TWideStringManager.UpperAnsiStringProc">
<short>Convert an ansistring to all-uppercase</short>
</element>

<element name="TWideStringManager.LowerAnsiStringProc">
<short>Convert an ansistring to all-lowercase</short>
</element>

<element name="TWideStringManager.CompareStrAnsiStringProc">
<short>Compare 2 ansistrings, case-sensitive</short>
</element>

<element name="TWideStringManager.CompareTextAnsiStringProc">
<short>Compare 2 ansistrings, case-insensitive</short>
</element>

<element name="TWideStringManager.StrCompAnsiStringProc">
<short>Compare 2 null-terminated ansistrings, case-sensitive</short>
</element>

<element name="TWideStringManager.StrICompAnsiStringProc">
<short>Compare 2 null-terminated ansistrings, case-insensitive</short>
</element>

<element name="TWideStringManager.StrLCompAnsiStringProc">
<short>Compare 2 null-terminated ansistrings, case-sensitive, for a maximum length</short>
</element>

<element name="TWideStringManager.StrLICompAnsiStringProc">
<short>Compare 2 null-terminated ansistrings, case-insensitive, for a maximum length</short>
</element>

<element name="TWideStringManager.StrLowerAnsiStringProc">
<short>Convert an ansistring to all-lowercase</short>
</element>

<element name="TWideStringManager.StrUpperAnsiStringProc">
<short>Convert an ansistring to all-uppercase</short>
</element>


<element name="StackTop">
<short>Top location of the stack.</short>
<descr>
<var>StackTop</var> contains the top of the stack for the current process.
It is used to check the heap on some operating systems, and is set by the 
system unit initialization code. Do not use or modify this value.
</descr>
<seealso>
<link id="StackBottom"/>
<link id="StackLength"/>
</seealso>
</element>


<element name="StringToWideChar">
<short>Convert a string to an array of widechars.</short>
<descr>
<var>StringToWideChar</var> converts an ansistring <var>Src</var> 
to a null-terminated  array of WideChars. The destination for this
array is pointed to by <var>Dest</var>, and contains room for at 
least <var>DestSize</var> widechars.
</descr>
<errors>
No validity checking is performed on <var>Dest</var>.
</errors>
<seealso>
<link id="WideCharToString"/>
<link id="WideCharToStrVar"/>
<link id="WideCharLenToStrVar"/>
<link id="WideCharLenToString"/>
</seealso>
</element>


<element name="SysGetFPCHeapStatus">
<short>Return the status of the FPC heapmanager</short>
<descr>
<var>SysGetFPCHeapStatus</var> returns the status of the 
default FPC heapmanager. It is set as the default value 
of the corresponding <link id="GetFPCHeapStatus"/> function.
</descr>
<errors>
None. The result of this function is bogus information if
the current heapmanager is not the standard FPC heapmanager.
</errors>
<seealso>
<link id="GetFPCHeapStatus"/>
</seealso>
</element>


<element name="tdynarraytypeinfo">
<short>Type information for a dynamic array.</short>
<descr>
<var>tdynarraytypeinfo</var> describes the structure of 
a multi-dimensional dynamical array. 
It is used in the <link id="DynArraySetLength"/> call.
</descr>
<seealso>
<link id="DynArraySetLength"/>
</seealso>
</element>

<element name="tdynarraytypeinfo.kind">
<short>Kind of array.</short>
</element>
<element name="tdynarraytypeinfo.namelen">
<short>Length of the Name of the array type. Name follows as Namelen characters.</short>
</element>
<element name="tdynarraytypeinfo.elesize">
<short>Size of a single element in the array</short>
</element>
<element name="tdynarraytypeinfo.eletype">
<short>Pointer to next dimension structure in case of a multidimensional array</short>
</element>
<element name="tdynarraytypeinfo.vartype">
<short>Type (variant type) of element in the array</short>
</element>


<element name="TError">
<short>Error type, used in variants.</short>
</element>


<element name="TFPCHeapStatus">
<short>Record describing the state of the default FPC heap manager.</short>
<descr>
<var>TFPCHeapStatus</var> describes the state of the FPC heap manager. 
This is not equivalent to the <link id="THeapStatus"/> record defined 
by Delphi, which contains information not meaningful for the FPC heap manager.
The heap status can be retrieved by the <link id="GetFPCHeapStatus"/> call.
</descr>
<seealso>
<link id="GetFPCHeapStatus"/>
<link id="GetHeapStatus"/>
<link id="THeapStatus"/>
</seealso>
</element>

<element name="TFPCHeapStatus.MaxHeapSize">
<short>Maximum allowed size for the heap, in bytes</short>
</element>

<element name="TFPCHeapStatus.MaxHeapUsed">
<short>Maximum used size for the heap, in bytes</short>
</element>

<element name="TFPCHeapStatus.CurrHeapSize">
<short>Current heap size, in bytes</short>
</element>

<element name="TFPCHeapStatus.CurrHeapUsed">
<short>Currently used heap size, in bytes</short>
</element>

<element name="TFPCHeapStatus.CurrHeapFree">
<short>Currently free memory on heap, in bytes</short>
</element>



<element name="TInterfacedClass">
<short><link id="#rtl.system.tobject">TObject</link> descendent implementing the <link id="#rtl.system.IInterface">IInterface</link> interface </short>
<descr>
<var>TInterfacedClass</var> is a descendent of 
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="TInterfacedObject">
<short><link id="#rtl.system.tobject">TObject</link> descendent implementing the <link id="#rtl.system.IUnknown">IUnknown</link> interface </short>
<descr>
<var>TInterfacedObject</var> is a descendent of <link id="TObject"/> which implements the
<link id="IUnknown"/> interface. It can be used as a base class for all classes which need
reference counting.
</descr>
<seealso>
<link id="IUnknown"/>
<link id="TObject"/>
</seealso>
</element>


<element name="TInterfacedObject.AfterConstruction">
<short>Handle reference count properly.</short>
<descr>
<var>AfterConstruction</var> overrides the basic method in <var>TObject</var> 
and adds some additional reference count handling.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TInterfacedObject.BeforeDestruction">BeforeDestruction</link>
</seealso>
</element>


<element name="TInterfacedObject.BeforeDestruction">
<short>Check reference count.</short>
<descr>
<var>AfterConstruction</var> overrides the basic method in <var>TObject</var> 
and adds a reference count check: if the reference count is not zero, an error
occurs.
</descr>
<errors>
A runtime-error 204 will be generated if the reference count is nonzero when 
the object is destroyed.
</errors>
<seealso>
<link id="TInterfacedObject.AfterConstruction">AfterConstruction</link>
</seealso>
</element>


<element name="TInterfacedObject.NewInstance">
<short>Create a new instance</short>
<descr>
<var>NewInstance</var> initializes a new instance of <link id="TInterfacedObject"/>
</descr>
<errors>
None.
</errors>
</element>


<element name="TInterfacedObject.RefCount">
<short>Return the current reference count</short>
<descr>
<var>RefCount</var> returns the current reference count. 
This reference count cannot be manipulated, except through 
the methods of <link id="IUnknown"/>. When it reaches zero,
the class instance is destroyed.
</descr>
<seealso>
<link id="IUnknown"/>
</seealso>
</element>


<element name="TObject.GetInterface">
<short>Return a reference to an interface</short>
<descr>
<p>
<var>GetInterface</var> scans the interface tables and returns a reference
to the interface <var>iid</var>. The reference is stored in <var>Obj</var> 
which should be an interface reference. It returns <var>True</var> if the 
interface was found, <var>False</var> if not.
</p>
<p>
The reference count of the interface is increased by this call.
</p>
</descr>
<errors>
If no interface was found, <var>False</var> is returned.
</errors>
<seealso>
<link id="TObject.GetInterfaceByStr">GetInterfaceByStr</link>
</seealso>
</element>


<element name="TObject.GetInterfaceByStr">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="TObject.GetInterfaceEntry">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="TObject.GetInterfaceEntryByStr">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="TObject.GetInterfaceTable">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="TResourceHandle">
<short>Handle to a resource, for use in the resource loading routines</short>
<descr>
This is an opaque type. 
</descr>
<seealso>
<link id="LoadResource"/>
</seealso>
</element>


<element name="TRuntimeError">
<short>Type of runtime-error for the Error procedure</short>
<descr>
<var>TRuntimeError</var> is used in the <link id="Error"/> procedure to
indicate what kind of error should be reported. 
</descr>
<seealso>
<link id="Error"/>
</seealso>
</element>


<element name="TRuntimeError.reAccessViolation">
<short>Access Violation</short>
</element>


<element name="TRuntimeError.reAssertionFailed">
<short>Assertion failed error</short>
</element>


<element name="TRuntimeError.reCodesetConversion">
<short>Code set conversion error</short>
</element>


<element name="TRuntimeError.reControlBreak">
<short>User pressed CTRL-C</short>
</element>


<element name="TRuntimeError.reDivByZero">
<short>Division by zero error</short>
</element>


<element name="TRuntimeError.reExternalException">
<short>An external exception occurred</short>
</element>


<element name="TRuntimeError.reIntfCastError">
<short>Interface typecast error</short>
</element>


<element name="TRuntimeError.reIntOverflow">
<short>Integer overflow error</short>
</element>


<element name="TRuntimeError.reInvalidCast">
<short>Invalid (class) typecast error</short>
</element>


<element name="TRuntimeError.reInvalidOp">
<short>Invalid operation error</short>
</element>


<element name="TRuntimeError.reInvalidPtr">
<short>Invalid pointer error</short>
</element>


<element name="TRuntimeError.reNone">
<short>No error</short>
</element>


<element name="TRuntimeError.reOutOfMemory">
<short>Out of memory error</short>
</element>


<element name="TRuntimeError.reOverflow">
<short>Overflow error</short>
</element>


<element name="TRuntimeError.rePrivInstruction">
<short>Privileged instruction error</short>
</element>


<element name="TRuntimeError.reQuit">
<short>Quit signal error</short>
</element>


<element name="TRuntimeError.reRangeError">
<short>Range check error</short>
</element>


<element name="TRuntimeError.reSafeCallError">
<short>Safecall (IDispInterface) error</short>
</element>


<element name="TRuntimeError.reStackOverflow">
<short>Stack overflow error</short>
</element>


<element name="TRuntimeError.reUnderflow">
<short>Underflow error</short>
</element>


<element name="TRuntimeError.reVarArrayBounds">
<short>Variant array bounds error</short>
</element>


<element name="TRuntimeError.reVarArrayCreate">
<short>Variant array creation error</short>
</element>


<element name="TRuntimeError.reVarDispatch">
<short>Variant Dispatch error.</short>
</element>


<element name="TRuntimeError.reVarInvalidOp">
<short>Invalid variant operation error</short>
</element>


<element name="TRuntimeError.reVarNotArray">
<short>Variant is not an array error.</short>
</element>


<element name="TRuntimeError.reVarTypeCast">
<short>Invalid typecase from variant</short>
</element>


<element name="TRuntimeError.reZeroDivide">
<short>Division by zero error</short>
</element>


<element name="TSafeCallErrorProc">
<short>Prototype for the safecall error handler</short>
<descr>
Prototype of a safecall error handler routine. <var>Error</var> is the error
number (passed by the Windows operating system) and <var>Addr</var> is the
address where the error occurred.
</descr>
<seealso>
<link id="SafeCallErrorProc"/>
</seealso>
</element>

<element name="TSafeCallErrorProc.error">
<short>Error number</short>
</element>

<element name="TSafeCallErrorProc.addr">
<short>Address where error occurred</short>
</element>



<element name="UCS4StringToWideString">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="UnicodeToUtf8">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>




<element name="UTF8Decode">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="UTF8Encode">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="Utf8ToAnsi">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="Utf8ToUnicode">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="VarCast">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="varrecord">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="WideCharLenToString">
<short>Convert a length-limited array of widechar to an ansistring</short>
<descr>
<var>WideCharLenToString</var> converts at most <var>Len</var> widecharacters from 
the null-terminated widechar array <var>S</var> to an ansistring, and returns 
the ansistring.
</descr>
<errors>
No validity checking is performed on <var>S</var>. 
Passing an invalid pointer may lead to access violations.
</errors>
<seealso>
<link id="StringToWideChar"/>
<link id="WideCharToString"/>
<link id="WideCharToStrVar"/>
<link id="WideCharLenToStrVar"/>
</seealso>
</element>

<element name="WideCharLenToStrVar">
<short>Convert a length-limited array of widechar to an ansistring</short>
<descr>
<var>WideCharLenToString</var> converts at most <var>Len</var> widecharacters from 
the null-terminated widechar array <var>Src</var> to an ansistring, and returns 
the ansistring in <var>Dest</var>.
</descr>
<errors>
No validity checking is performed on <var>Src</var>. 
Passing an invalid pointer may lead to access violations.
</errors>
<seealso>
<link id="StringToWideChar"/>
<link id="WideCharToString"/>
<link id="WideCharToStrVar"/>
<link id="WideCharLenToString"/>
</seealso>
</element>


<element name="WideCharToString">
<short>Convert a null-terminated array of widechar to an ansistring</short>
<descr>
<var>WideCharToString</var> converts the null-terminated widechar 
array <var>S</var> to an ansistring, and returns the ansistring.
</descr>
<errors>
No validity checking is performed on <var>Src</var>. 
Passing an invalid pointer, or an improperly terminated array may 
lead to access violations.
</errors>
<seealso>
<link id="StringToWideChar"/>
<link id="WideCharToStrVar"/>
<link id="WideCharLenToStrVar"/>
<link id="WideCharLenToString"/>
</seealso>
</element>

<element name="WideCharToStrVar">
<short>Convert a null-terminated array of widechar to an ansistring</short>
<descr>
<var>WideCharToString</var> converts the null-terminated widechar 
array <var>S</var> to an ansistring, and returns the ansistring in <var>Dest</var>.
</descr>
<errors>
No validity checking is performed on <var>S</var>. 
Passing an invalid pointer, or an improperly terminated array may 
lead to access violations.
</errors>
<seealso>
<link id="StringToWideChar"/>
<link id="WideCharToString"/>
<link id="WideCharToStrVar"/>
<link id="WideCharLenToString"/>
</seealso>
</element>


<element name="widestringmanager">
<short>Current widestring manager.</short>
<descr>
Contains the current widestring manager. Do not use directly.
</descr>
<seealso>
<link id="GetWideStringManager"/>
<link id="SetWideStringManager"/>
</seealso>
</element>


<element name="WideStringToUCS4String">
<short>Convert a widestring to a UCS-4 encoded string.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="operator and(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(ansistring): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(ansistring): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Boolean): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Boolean): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Byte): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Byte): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Char): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Char): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(currency): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(currency): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator div(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(double): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(double): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(DWord): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(DWord): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Int64): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Int64): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(longbool): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(longbool): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(LongInt): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(LongInt): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator mod(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator not(variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): ansistring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): Byte">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): Char">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): currency">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): double">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): DWord">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): Int64">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): longbool">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): LongInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): qword">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): ShortInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): shortstring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): SmallInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): TDateTime">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): TError">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): widechar">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): widestring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): Word">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(olevariant): wordbool">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator or(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(qword): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(qword): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(real48): double">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator shl(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(ShortInt): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(ShortInt): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(shortstring): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(shortstring): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator shr(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(SmallInt): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(SmallInt): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(TDateTime): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(TDateTime): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(TError): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(TError): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): ansistring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): Byte">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): Char">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): currency">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): double">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): DWord">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): Int64">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): longbool">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): LongInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): qword">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): ShortInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): shortstring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): SmallInt">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): TDateTime">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): TError">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator -(variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator &lt;=(variant, variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator &lt;(variant, variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator =(variant, variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator &gt;=(variant, variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator &gt;(variant, variant): Boolean">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator -(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator /(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator *(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator **(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator +(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): widechar">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): widestring">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): Word">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(variant): wordbool">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(widechar): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(widechar): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(widestring): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(widestring): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(wordbool): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(wordbool): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Word): olevariant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator :=(Word): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="operator xor(variant, variant): variant">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SwapEndian">
<short>Swap endianness of the argument</short>
<descr>
<var>SwapEndian</var> will swap the endianness of the bytes in its argument.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="hi"/>
<link id="lo"/>
<link id="swap"/>
<link id="BEToN"/>
<link id="NToBE"/>
<link id="NToLE"/>
<link id="LEToN"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InterLockedIncrement">
<short>Thread-safe increment</short>
<descr>
<var>InterLockedIncrement</var> increments <var>Target</var> with 1 and returns the result.
This is done in a thread-safe way (i.e. only one processor is accessing the variable at a time).
</descr>
<errors>
None.
</errors>
<seealso>
<link id="InterLockedDecrement"/>
<link id="InterLockedExchange"/>
<link id="InterLockedExchangeAdd"/>
<link id="InterlockedCompareExchange"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InterLockedDecrement">
<short>Thread-safe decrement</short>
<descr>
<var>InterLockedDecrement</var> decrements <var>Target</var> with 1 and returns the result.
This is done in a thread-safe way. (i.e. only one processor is accessing the variable at a time).
</descr>
<errors>
None.
</errors>
<seealso>
<link id="InterLockedIncrement"/>
<link id="InterLockedExchange"/>
<link id="InterLockedExchangeAdd"/>
<link id="InterlockedCompareExchange"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InterLockedExchange">
<short>Exchange 2 integers in a thread-safe way</short>
<descr>
<var>InterLockedExchange</var> stores <var>Source</var> in <var>Target</var> and returns the old value of <var>Target</var>. 
This is done in a thread-safe way, i.e., only one processor is accessing the <var>Target</var> variable at a time.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="InterLockedDecrement"/>
<link id="InterLockedIncrement"/>
<link id="InterLockedExchangeAdd"/>
<link id="InterlockedCompareExchange"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InterLockedExchangeAdd">
<short>Thread-safe add and exchange of 2 values</short>
<descr>
<var>InterlockedDecrement</var> adds to <var>Target</var> the value of <var>Source</var> in a thread-safe way, 
and returns the old value of <var>Target</var>.This is done in a thread-safe way, i.e., only one 
processor is accessing the <var>Target</var> variable at a time.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="InterLockedDecrement"/>
<link id="InterLockedIncrement"/>
<link id="InterLockedExchange"/>
<link id="InterlockedCompareExchange"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="InterlockedCompareExchange">
<short>Conditional exchange</short>
<descr>
<var>InterlockedCompareExchange</var> does an  compare-and-exchange operation on the specified values in a thread-safe way. 
The function compares <var>Target</var> and <var>Comparand</var> and exchanges <var>Target</var> with <var>NewValue</var>
if <var>Target</var> and <var>Comparand</var> are equal. It returns the old value of <var>Target</var>. 
This is done in a thread-safe way, i.e., only one processor is accessing the <var>Target</var> variable at a time.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="InterLockedDecrement"/>
<link id="InterLockedIncrement"/>
<link id="InterLockedExchange"/>
<link id="InterLockedExchangeAdd"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.Data1">
<short>First 4 bytes of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.Data2">
<short>Bytes 5 and 6 of  GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.Data3">
<short>Bytes 7 and 8 of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.Data4">
<short>Bytes 9-17 of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.D1">
<short>First 4 bytes of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.D2">
<short>Bytes 5 and 6 of  GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.D3">
<short>Bytes 7 and 8 of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TGuid.D4">
<short>Bytes 9-17 of GUID</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VInteger">
<short>Integer value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VBoolean">
<short>Boolean value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VChar">
<short>Character value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VWideChar">
<short>Widechar value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VExtended">
<short>Extended value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VString">
<short>String value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VPointer">
<short>Pointer value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VPChar">
<short>PChar value (null-terminated string)</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VObject">
<short>Object value (instance pointer)</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VClass">
<short>Class pointer value (VMT pointer)</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VPWideChar">
<short>Widechar value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VAnsiString">
<short>Ansistring value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VCurrency">
<short>Currency value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VVariant">
<short>Variant value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VInterface">
<short>Interface value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VWideString">
<short>Widestring value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VInt64">
<short>Int64 value</short>
</element>

<!-- variable Visibility: default -->
<element name="TVarRec.VQWord">
<short>QWord value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.res1">
<short>Reserved byte</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.res2">
<short>Reserved byte</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.res3">
<short>Reserved byte</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vsmallint">
<short>Smallint value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vinteger">
<short>Integer value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vsingle">
<short>Single value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vdouble">
<short>Double value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vcurrency">
<short>Currency value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vdate">
<short>TDateTime value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.volestr">
<short>OLE string value (specially allocated widestring)</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vdispatch">
<short>Dispatch interface value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.verror">
<short>Error value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vboolean">
<short>Boolean value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vunknown">
<short>IUnknown interface value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vshortint">
<short>Shortint value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vbyte">
<short>Byte value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vword">
<short>Word value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vlongword">
<short>Longword value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vint64">
<short>Int64 value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vqword">
<short>QWord value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vword64">
<short>QWord value (?)</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vstring">
<short>Ansistring value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vany">
<short>Any valyue</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.varray">
<short>Variant array value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vpointer">
<short>Pointer value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vlongs">
<short>Value as an array of longints</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vwords">
<short>Value as an array of words</short>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vbytes">
<short>Value as an array of bytes</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.TotalAddrSpace">
<short>Total amount of available addressable memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.TotalUncommitted">
<short>Total amount of uncommitted memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.TotalCommitted">
<short>Total amount of committed memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.TotalAllocated">
<short>Total amount of allocated memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.TotalFree">
<short>Total amount of free memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.FreeSmall">
<short>Total amount of free small memory blocks</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.FreeBig">
<short>Total amount of free large memory blocks</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.Unused">
<short>Total amount of free process memory</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.Overhead">
<short>Total bytes of overhead by memory manager </short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.HeapErrorCode">
<short>Last error code</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.GetFPCHeapStatus">
<short>Handler to get FPC heap status information.</short>
</element>

</module>
</package>
</fpdoc-descriptions>
